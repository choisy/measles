---
title: "SEIR Metapopulation Contact Model"
output:
  html_document:
    toc: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::knit_hooks$set(
  margin1 = function(before, options, envir) {
    if (before) par(mgp = c(1.5, .5, 0), bty = "n", plt = c(.105, .97, .13, .97))
    else NULL
  },
  margin2 = function(before, options, envir) {
    if (before) par(mgp = c(2, .5, 0), bty = "n", plt = c(.105, .97, .13, .97))
    else NULL
  },
  margin3 = function(before, options, envir) {
    if (before) par(mgp = c(1.5, .5, 0), bty = "n", mai = rep(.1, 4))
    else NULL
  }
)

knitr::opts_chunk$set(echo       = TRUE,
                      cache      = TRUE,
                      margin1    = TRUE,
                      fig.retina = 2,
                      fig.align  = "center")

l <- "en_US.UTF-8"
Sys.setenv(LANGAGE = l)
Sys.setlocale(locale = l)
Sys.setlocale("LC_MESSAGES", l)
```

## Links to local data sets

Here we use the following links to data.

```{r}
GADM_census_path <- "~/Desktop/OUCRU/FacebookData/ColocationMarc/GADM_census.rds"
coloc_mat_path <- "~/Desktop/OUCRU/FacebookData/ColocationMarc/coloc_mat.rds"
GADM_country_path <- "~/Desktop/OUCRU/FacebookData/ColocationMarc/gadm36_VNM_0_sf.rds"
```

Change them accordingly if you want to run the script locally on your computer.

## Packages

The needed packages:

```{r message = FALSE}
library(sf)
library(stars)
library(tidyr)
library(magrittr)
library(purrr)
library(dplyr) # best to load last
library(reshape2)
library(data.table)
library(ggplot2)
```

## Read in local data sets

```{r}
dist_polygons <- readRDS(GADM_census_path)
coloc_mat <- readRDS(coloc_mat_path)
vn0 <- readRDS(GADM_country_path)
worldpop <- read_stars("VNM_ppp_v2b_2020_UNadj.tif")
```

Redefining the `hist()` function:

```{r}
hist2 <- function(...) hist(..., main = NA)
```

## SEIR Metapopulation Contact Model
The following model uses colocation data to formulate the coupling in a SEIR metapopulation model. The equations that describe the epidynamics in each of the populations is given below:
$$
\begin{aligned}
  \frac{dS_i}{dt} & = - S_i \sum_{k} \beta_{ik} \frac{I_k}{N_k} \\
  \frac{dE_i}{dt} & = S_i \sum_{k} \beta_{ik} \frac{I_k}{N_k} - \sigma E_i \\
  \frac{dI_i}{dt} & = \sigma E_i - \gamma I_i \\
  \frac{dR_i}{dt} & = \gamma I_i \\
\end{aligned}
$$
where $\frac{1}{\sigma} = 7$ days is the latency period and $\frac{1}{\gamma} = 7$ is the recovery period. Note that $N_i = S_i + E_i + I_i + R_i$. We assume that $\beta_{ik}$ which represents the transmission rate from population $k$ to population $i$ is proportional to $C_{ik}$, the colocation probability for population $i$ and population $k$.

## Parameterization Method 1
The following parameterization is an adaptation of the contact model given in the paper, [Modeling the impact of human mobility and travel restrictions on the potential spread of SARS-CoV-2 in Taiwan](https://www.medrxiv.org/content/10.1101/2020.04.07.20053439v1). 

The $\beta_{ik}$ are defined as follows:
$$
\begin{aligned}
  \beta_{ik} = \gamma R_{0 ik}
\end{aligned}
$$
where 
$$
\begin{aligned}
  R_{0 ik} & = R_{0 \: Hanoi'} \frac{C_{ij}}{C_{Hanoi'-Hanoi'}} \\
\end{aligned}
$$
and $Hanoi'$ is the district in Hà Nội with the highest density. This assumes that the strength of transmission from district $j$ to district $i$ is dependent on colocation probabilities and independent of the relative population sizes of the interacting regions. 

Let's calculate the district in Hanoi with the highest density. 
```{r}
HanoiDist <- dist_polygons %>%
  filter(province == "Hà Nội") %>% 
  arrange(desc(den_km2)) %>%
  head(1) %>%
  pull(district)

HanoiDistID <- dist_polygons %>%
  filter(province == "Hà Nội") %>%
  filter(district == HanoiDist) %>% 
  pull(polygon_id)
```
As such, we will set the $R_0$ of `r HanoiDist` to 18; that is, $R_{0 \: Hanoi'} = 18$. <br>

The following function computes the $R_{0 ik}$ values with the standard reference district with $R_0$ of `standardR0` and district ID of `standardDistID`. 
```{r}
compute_R0 <- function(coloc_mat, standardR0, standardDistID) {
  melt(coloc_mat) %>% 
    setNames(c("polygon1_id", "polygon2_id", "link_value")) %>%
    mutate(R0 = standardR0 * link_value / coloc_mat[paste(standardDistID), paste(standardDistID)])
}
```

Let's compute the $R_{0 ik}$ with $R_{0 \: Hanoi'} = 18$:
```{r warning=FALSE}
R0 <- compute_R0(coloc_mat, 18, HanoiDistID)
```

### Intracity $R_0$
Intracity $R_0$ is defined as $R_ii$. 

Let's see the distribution of the intracity $R_0$ values; that is, the distribution of $R_{0 ii}$ values. 
```{r}
intracityR0 <- R0 %>%
  filter(polygon1_id == polygon2_id) %>%
  rename(intraR0 = R0)
```

```{r}
hist2(intracityR0$intraR0, n = 50, xlab = "Intracity R0", ylab = "number of districts", axes = FALSE)
axis(1, seq(0, 60, 10))
axis(2)
```

```{r}
cb <- RColorBrewer::brewer.pal(9, "YlOrBr")
color_generator <- colorRampPalette(cb)
pal <- color_generator(10)
```

```{r}
hist2(intracityR0$intraR0, quantile(intracityR0$intraR0, seq(0, 1, le = 11)), col = pal, axes = FALSE,
      xlab = "Intracity R0", ylab = "density of probability")
axis(1, seq(0, 60, 10))
axis(2)
```

```{r}
quantile(intracityR0$intraR0, seq(0, 1, le = 11))
```

Surprisingly, we see that there are several districts with intracity $R_0$ values greater than 20. This is far higher than what you would expect for measles. Let's see what cities in particular have these high intracity $R_0$ values. 

Let's map the intracity $R_0$ values for the districts:
```{r}
intracityR0sf <- dist_polygons %>%
  right_join(select(intracityR0, -polygon2_id), c("polygon_id" = "polygon1_id"))
```

The following district have intracity $R0$ greater than 10. 
```{r}
vn0 %>% 
  st_geometry() %>% 
  plot(col = "grey")

intracityR0sf %>%
  select("intraR0") %>% 
  filter(intraR0 > 10) %>%
  plot(add = TRUE, col = "red")
```

The following districts have intracity $R0$ greater than 20. 
```{r}
intracityR0sf %>% 
  filter(intraR0 > 20) %>%
  arrange(desc(intraR0)) %>%
  st_drop_geometry() %>%
  select(province, district, intraR0)
```

```{r}
vn0 %>% 
  st_geometry() %>% 
  plot(col = "grey")

intracityR0sf %>% 
  filter(intraR0 > 20) %>% 
  select(intraR0) %>% 
  plot(add = TRUE, col = "red")
```

It appears that remote regions of Vietnam have relatively higher intracity $R_0$ values. Let's verify this by graphing relationship between population density and intracity $R_0$ values under the assumption that more remote regions will have lower population densities. 

```{r}
ggplot(intracityR0sf, aes(x = log10(den_km2), y = intraR0)) + geom_point()
```

Both populations with relatively low population densities and populations with relatively high population densities have high intracity $R_0$ values. Populations with especially low densities have the greatest intracity $R_0$ values. Note that we should see a positive relationship between population density and intracity $R_0$ values. The intracity $R_0$ values need to be adjusted to fix the artifact of how the colocation matrix is constructed. 

### Intercity $R_0$
Intercity $R_0$ for location $i$ is defined as $\sum_{j \neq i} R_{0 ij}$. 

Let's consider the intercity R0 values:
```{r}
intercityR0 <- R0 %>%
  filter(polygon1_id != polygon2_id) %>%
  rename(interR0 = R0)

totalInter <- intercityR0 %>%
  group_by(polygon1_id) %>%
  summarize(interR0 = sum(interR0)) %>%
  arrange(desc(interR0))
```

Let's map the intracity $R_0$ values for the districts:
The following districts have intercityR0 values greater than 1:
```{r}
intercityR0sf <- dist_polygons %>%
  right_join(totalInter, c("polygon_id" = "polygon1_id"))
```

```{r}
vn0 %>% 
  st_geometry() %>% 
  plot(col = "grey")

intercityR0sf %>%
  select("interR0") %>% 
  filter(interR0 > 1) %>%
  plot(add = TRUE, col = "red")
```

Let's graph the relationship between population density and intercity $R_0$ values:
```{r}
ggplot(intercityR0sf, aes(x = log10(den_km2), y = interR0)) + geom_point()
```

As we would expect, population centers with higher population densities are better connected with surrounding regions resulting in higher intercity $R_0$ values. Hence, the intercity $R_0$ values under this model are consistent with epidemiological assumptions. 

### Intercity and Intracity $R_0$ values
Let's graph the relationship between intracity $R_0$ values and intercity $R_0$ values:
```{r}
tmp <- intercityR0sf %>%
  right_join(select(intracityR0, -polygon2_id, -link_value), c("polygon_id" = "polygon1_id"))
```

```{r}
ggplot(tmp, aes(x = intraR0, y = interR0)) + geom_point() +
  geom_abline(slope = 1, intercept = 0)
```

There are two distinct groups in the plot: one group has larger intercity $R_0$ values relative to intracity $R_0$ values, while the other has larger intracity $R_0$ values relative to intercity $R_0$ values. 

Let's use a linear mixture model to assign each point to a particular linear model:

```{r}
library(flexmix)
set.seed(10)
model <- flexmix(interR0 ~ intraR0, tmp, k = 2)
summary(model)
```

```{r}
plot(tmp$interR0, tmp$intraR0, col = clusters(model), 
     xlab = "intercity R0", ylab = "intracity R0")
```

Let's map the clustering observed in the linear mixture model to the districts:
```{r}
vn0 %>% 
  st_geometry() %>% 
  plot(col = "grey")

colors <- clusters(model)
colors[colors == 1] = 3

tmp %>% 
  transmute(cluster = clusters(model)) %>%
  st_geometry() %>%
  plot(add = TRUE, col = colors)
```

It is a little noisy, so let's take a closer look at the districts that are "clearly" in one group or the other; that is, districts with posterior probabilities that indicate clear membership to one of the linear regression models. 

```{r}
postProb <- posterior(model) %>%
  as.data.frame() %>%
  transmute(model1 = V1, model2 = V2, cluster = clusters(model)) %>%
  mutate(m1Vm2 = model1/model2, m2Vm1 = model2/model1)
```

```{r}
tmpPost <- tmp %>% 
  transmute(cluster = postProb$cluster, m1Vm2 = postProb$m1Vm2, 
            m2Vm1 = postProb$m2Vm1)
```

```{r}
vn0 %>% 
  st_geometry() %>% 
  plot(col = "grey")

tmpPost %>% 
  filter(cluster == 1) %>%
  arrange(desc(m1Vm2)) %>%
  head(50) %>%
  st_geometry() %>%
  plot(add = TRUE, col = 3)

tmpPost %>% 
  filter(cluster == 2) %>%
  arrange(desc(m2Vm1)) %>%
  head(50) %>%
  st_geometry() %>%
  plot(add = TRUE, col = 2)
```

The districts with high intercity $R_0$ relative to intracity $R_0$ are clustered around Hanoi and Ho Chi Minh, while the districts with low intercity $R_0$ relative to intracity $R_0$ are clustered in remote regions. 

## Parameterization Method 2
The $\beta_{ik}$ are defined as follows:
$$
\begin{aligned}
  \beta_{ik} = \gamma R_{0 ik}
\end{aligned}
$$
where 
$$
\begin{aligned}
  R_{0 ik} & = R_{0 \: Hanoi'} \frac{C_{ij} N_j}{C_{Hanoi'-Hanoi'} \cdot N_{Hanoi'}} \\
\end{aligned}
$$
and $Hanoi'$ is the district in Hà Nội with the highest density. The numerator represents the average number of individuals from population $j$ that colocate with an individual from population $i$ per unit time, whereas the denominator is the average number of colocations among individuals in the densest district in Hanoi per unit time. This formulation scales the colocation probability by the population size of the interacting district. 

The following function computes the $R_{0 ik}$ values with the standard reference district with $R_0$ of `standardR0` and district ID of `standardDistID`. 
```{r}
compute_R0 <- function(dist_data, coloc_mat, standardR0, standardDistID) {
  popHanoiDist <- dist_data %>% 
    filter(polygon_id == HanoiDistID) %>% 
    pull(n)
  
  coloc_mat <- reshape2::melt(coloc_mat) %>% 
    setNames(c("polygon1_id", "polygon2_id", "link_value")) %>%
    dplyr::right_join(select(as.data.frame(dist_data), polygon_id, n), 
                      c("polygon2_id" = "polygon_id")) %>%
    dplyr::mutate(R0 = standardR0 * link_value * n / 
             (coloc_mat[paste(standardDistID), paste(standardDistID)] * popHanoiDist))
}
```

Let's compute the $R_{0 ik}$ with $R_{0 \: Hanoi'} = 18$:
```{r warning=FALSE}
R0 <- compute_R0(dist_polygons, coloc_mat, 18, HanoiDistID)
```

### Intracity $R_0$
Intracity $R_0$ is defined as $R_ii$. 

Let's see the distribution of the intracity $R_0$ values; that is, the distribution of $R_{0 ii}$ values. 
```{r}
intracityR0 <- R0 %>%
  filter(polygon1_id == polygon2_id) %>%
  rename(intraR0 = R0)
```

```{r}
hist2(intracityR0$intraR0, n = 50, xlab = "Intracity R0", ylab = "number of districts", axes = FALSE)
axis(1, seq(0, 20, 2))
axis(2)
```

```{r}
cb <- RColorBrewer::brewer.pal(9, "YlOrBr")
color_generator <- colorRampPalette(cb)
pal <- color_generator(10)
```

```{r}
hist2(intracityR0$intraR0, quantile(intracityR0$intraR0, seq(0, 1, le = 11)), col = pal, axes = FALSE,
      xlab = "Intracity R0", ylab = "density of probability")
axis(1, seq(0, 20, 2))
axis(2)
```

```{r}
quantile(intracityR0$intraR0, seq(0, 1, le = 11))
```

The intracity $R_0$ values are far more reasonable for measles. 

Let's map the intracity $R_0$ values for the districts:
```{r}
intracityR0sf <- dist_polygons %>%
  right_join(select(intracityR0, -polygon2_id, -n), c("polygon_id" = "polygon1_id"))
```

The following district have intracity $R0$ greater than 5.
```{r}
vn0 %>% 
  st_geometry() %>% 
  plot(col = "grey")

intracityR0sf %>%
  select("intraR0") %>% 
  filter(intraR0 > 5) %>%
  plot(add = TRUE, col = "red")
```
While there is slightly more clustering around the population centers of Hanoi and Ho Chi Minh, there is still high intracity $R_0$ values in relatively remote regions. 

Let's explore the relationship between population density and intracity $R_0$ values under the assumption that more remote regions will have lower population densities. 
```{r}
ggplot(intracityR0sf, aes(x = log10(den_km2), y = intraR0)) + geom_point()
```
This is a large improvement from the previous model, but there are still districts with low densities that have high intracity $R_0$ values. One would assume that remote regions with low densities would have smaller within-district colocation probabilities because people are so sparsely located and rarely interact. This property, however, may be due to the fact that the majority of the population within these small districts reside only a small area of the much larger district; therefore, although the district has a low population density overall, the areas where residents actually reside may be quite dense. This could result in a high within-district colocation probability and consequently a high intracity $R_0$. This hypothesis will be tested below. 

### Intercity $R_0$
Intercity $R_0$ for location $i$ is defined as $\sum_{j \neq i} R_{0 ij}$. 

Let's consider the intercity R0 values:
```{r}
intercityR0 <- R0 %>%
  filter(polygon1_id != polygon2_id) %>%
  rename(interR0 = R0)

totalInter <- intercityR0 %>%
  group_by(polygon1_id) %>%
  summarize(interR0 = sum(interR0)) %>%
  arrange(desc(interR0))
```

Let's map the intracity $R_0$ values for the districts:
The following districts have intercityR0 values greater than 1:
```{r}
intercityR0sf <- dist_polygons %>%
  right_join(totalInter, c("polygon_id" = "polygon1_id"))
```

```{r}
vn0 %>% 
  st_geometry() %>% 
  plot(col = "grey")

intercityR0sf %>%
  select("interR0") %>% 
  filter(interR0 > 1) %>%
  plot(add = TRUE, col = "red")
```

The districts with high intercity $R_0$ values are clustered in high density/highly connected regions including Hanoi and Ho Chi Minh, which is what we would expect. 

Let's graph the relationship between population density and intercity $R_0$ values:
```{r}
ggplot(intercityR0sf, aes(x = log10(den_km2), y = interR0)) + geom_point()
```

As we would expect, population centers with higher population densities are better connected with surrounding regions resulting in higher intercity $R_0$ values. Hence, the intercity $R_0$ values under this model are consistent with epidemiological assumptions. Implicit in this analysis is the assumption that districts with higher population densities are better connected to surrounding regions. In general, this assumption holds because districts which have high population densities tend to have advanced transport networks that facilitate travel between other districts. 

### Intercity and Intracity $R_0$ values
Let's graph the relationship between intracity $R_0$ values and intercity $R_0$ values:
```{r}
tmp <- intercityR0sf %>%
  right_join(select(intracityR0, -polygon2_id, -link_value), c("polygon_id" = "polygon1_id"))
```

```{r}
ggplot(tmp, aes(x = intraR0, y = interR0)) + geom_point() +
  geom_abline(slope = 1, intercept = 0)
```

The grouping that we observed in the first model has largely disappeared. There are a few disticts with high intracity $R_0$ values in comparison to intercity $R_0$ which may be a point of concern. As we would expect, however, the intracity $R_0$ values are weakly proportional to the intercity $R_0$ values. 

### Risk of Infection
Let's define the risk of infection for a location $i$ as follows:
$$
\begin{aligned}
  \text{Risk of infection for location i} = \frac{\sum_{j \: includes \: i } R_{0 ij}}{\text{max}_l(\sum_{j \: includes \: l} R_{0 lj})}
\end{aligned}
$$
The sum of intracity $R_0$ and intercity $R_0$ reflects total risk of infection and was standardized to the highest sum of intracity $R_0$ and intercity $R_0$. 

Let's calculate it for all districts:
```{r}
ROIdf <- R0 %>% 
  group_by(polygon1_id) %>%
  summarize(ROI = sum(R0)) %>%
  rename(polygon_id = polygon1_id) %>%
  arrange(desc(ROI)) %>%
  mutate(ROI = ROI / head(., 1)$ROI)

ROIsf <- dist_polygons %>%
  right_join(ROIdf, "polygon_id")
```

It look like this:
```{r}
ROIsf %>%
  arrange(desc(ROI)) %>%
  select(province, district, den_km2, ROI) %>%
  st_drop_geometry() %>%
  head(30)
```

The districts with the highest risk of infection are located in Hanoi and Ho Chi Minh provinces. There are a few districts with very low population densities (Ha Giang Province in Northern Vietnam) that have relatively high risks of infection, which are presumably attributable to the fact that they are concentrated within a small region of the much large district and do not travel outside the population leading to very high $C_{ii}$ values in the colocation matrix. This is tested below. 

```{r}
hist2(ROIsf$ROI, n = 50, xlab = "Intracity R0", ylab = "number of districts", axes = FALSE)
axis(1, seq(0, 1, 0.1))
axis(2)
```

Let's map the risk of infection to the districts:
```{r}
ROIsf %>%
  st_geometry() %>%
  plot(lwd = .1, col = pal[cut(ROIsf$ROI, quantile(ROIsf$ROI, seq(0, 1, le = 11)))], main = NA)

vn0 %>%
  st_geometry() %>%
  plot(add = TRUE)
```

Let's examine the relationship between population density and risk of infection:
```{r}
ggplot(ROIsf, aes(x = log10(den_km2), y = ROI)) + 
  geom_point() +
  geom_point(data = filter(ROIsf, province == "Hà Giang"), aes(x= log10(den_km2), y = ROI), color='red')
```
Generally, risk of infection increases with population density. We see, however, that some populations with low densities have high risks of infection. In particular, the districts in the Hà Giang province, which have particularly high ROI for the relatively low population densities are highlighted red.

Let's break down the risk of infection into risk of infection due to intracity transmission and risk of infection due to intercity transmission for each district. 
```{r}
tmp <- totalInter %>%
  right_join(select(intracityR0, polygon1_id, intraR0, n), "polygon1_id") %>%
  rename(polygon_id = polygon1_id) %>%
  mutate(interROI = interR0 / (interR0 + intraR0)) %>%
  filter(interROI != "NaN")

interROI <- dist_polygons %>%
  right_join(select(tmp, polygon_id, interR0, intraR0, interROI), "polygon_id")
```

It look like this:
```{r}
interROI %>%
  arrange(desc(interROI)) %>%
  select(polygon_id, province, district, den_km2, interROI) %>%
  st_drop_geometry() %>%
  head(30)
```

Let's map the percent ROI attributable to intercity transmission: 
```{r}
interROI %>%
  st_geometry() %>%
  plot(lwd = .1, col = pal[cut(interROI$interROI, quantile(interROI$interROI, seq(0, 1, le = 11)))], main = NA)

vn0 %>%
  st_geometry() %>%
  plot(add = TRUE)
```

Many of the districts with high ROI actually have relatively low ROI attributable to intercity transmission. This suggests that such the populations of such districts are isolated and a concentrated within a small region of the much larger district. Therefore, if a infected individual were to be introduced into a remote population with a high ROI (a rare event), the disease transmission within the district will be high because the individuals in the community are strongly connected. This will rarely happen, however, given how weak such a districts intercity interactions are with other populations. 

## Explorations of Hà Giang Province: high ROI and low density 
The Hà Giang Province has a number of districts with high intracity $R_0$ values in spite of their relatively low population densities; in fact, their population densities place them in the first quartile among all districts in Vietnam. One would assume that remote regions with low densities would have smaller within-district colocation probabilities because people are so sparsely located and rarely interact. The counter-intuitive property displayed by some districts in the Hà Giang Province may be attributable to the fact that the majority of the population within these small districts reside only a small area of the much larger district; therefore, although the district has a low population density overall, the areas where residents actually reside may be quite dense. This could result in a high within-district colocation probability and consequently a high intracity $R_0$.

There are 10 districts in the Hà Giang province, which is identified below:
```{r}
plot(st_geometry(vn0), col = "grey")

dist_polygons %>%
  filter(province == "Hà Giang") %>%
  st_geometry() %>%
  plot(add = TRUE, col = "yellow")
```

In order to characterize how evenly the population is spread in the district, the actual population density of each Bing pixel is compared to the population density of each Bing pixel if the population was perfectly spread out over all the pixels. This is captured by the shaded area in the following graph, where a smaller area corresponds to a more spread out population.
```{r include = FALSE, warning = FALSE, eval = TRUE}
dist <- dist_polygons %>% 
    filter(polygon_id == 834527)

tmp <- worldpop %>%
  st_crop(dist) %>%
  st_as_stars() %>%
  unlist() %>%
  na.omit() %>%
  as.vector() %>%
  sort(decreasing = TRUE)

cumsum <- (tmp / sum(tmp)) %>% cumsum() 
```

```{r}
xaxis <- seq(0, 1, length.out = length(cumsum))
plot(x = xaxis, y = cumsum, type = "l", axes = FALSE,
     xlab = "cumulative proportion of pixels in the district", 
     ylab = "cumulative proportion of the district population")
abline(0, 1)
polygon(x = c(xaxis, xaxis), y = c(cumsum, xaxis), col = adjustcolor("green", .2))
axis(1, seq(0, 1, by = 0.1))
axis(2, seq(0, 1, by = 0.1))
```

The following function computes the area-under-curve (AUC) statistic for the district with `polygon_ID` according to the `worldpop` data set. 
```{r warning = FALSE}
compute_AUC <- function(polygon_ID, polygons = dist_polygons, rstr = worldpop) {
  dist <- polygons %>% 
    filter(polygon_id == polygon_ID)
  
  tmp <- worldpop %>%
    st_crop(dist) %>%
    st_as_stars() %>%
    unlist() %>%
    na.omit() %>%
    as.vector() %>%
    sort(decreasing = TRUE)
  
  cumsum <- (tmp / sum(tmp)) %>% cumsum() 
  (cumsum / length(cumsum)) %>% sum() - 0.5
}
```

Let's compute the area-under-curve (AUC) statistic for each of the districts:
```{r eval = FALSE}
dist_AUCs <- unlist(purrr::map(pull(dist_polygons, polygon_id), compute_AUC)) %>%
  data.frame(polygon_id = pull(dist_polygons, polygon_id), AUC = .)
```

```{r eval = FALSE, include = FALSE}
saveRDS(dist_AUCs, "dist_AUC.RDS")
```

```{r include = FALSE}
dist_AUCs <- readRDS("dist_AUC.RDS")
```

Let's check whether there are any districts with no population according to [WorldPop](https://www.worldpop.org):
```{r}
no_pop <- dist_AUCs %>%
  filter(AUC == -0.5) %>%
  pull(polygon_id)

dist_polygons %>%
  filter(polygon_id %in% no_pop) %>%
  select(polygon_id, province, district) %>%
  st_drop_geometry()
```

Let's map these districts without population data:
```{r warning = FALSE}
vn0 %>% 
  st_geometry() %>% 
  plot(col = "grey")

dist_polygons %>%
  filter(polygon_id %in% no_pop) %>% 
  st_centroid() %>%
  st_geometry() %>%
  plot(pch = 3, col = 'red', add = TRUE)
```
All the districts without population data are islands off the coast of Vietnam. 

Let's remove these data points from the AUC data set.
```{r}
dist_AUCs %<>% 
  filter(AUC != -0.5)
```

Let's examine the distribution of the AUC statistics:
```{r}
hist2(dist_AUCs$AUC, n = 50, axes = FALSE, 
      xlab = "area-under-curve (AUC)", ylab = "number of districts")
axis(1, seq(0, 0.4, 0.05))
axis(2, seq(0, 50, 10))
```

```{r}
tmp <- ROIsf %>%
  right_join(dist_AUCs, "polygon_id")

ggplot(tmp, aes(x = log10(den_km2), y = ROI)) + geom_point(aes(color = AUC))
```

Those districts with high ROI (above 0.25) and low density (below 300 / km2) do not necessarily have low AUC values. As such, the hypothesis that this property is attributable to the fact that the the majority of the population is concentrated in a small area relative to the district as whole may not hold. An alternative explanation may need to be sought. 

Let's map the AUC distribution:
```{r}
dist_polygons %>%
  right_join(dist_AUCs, "polygon_id") %>%
  st_geometry() %>%
  plot(lwd = .1, col = pal[cut(dist_AUCs$AUC, quantile(dist_AUCs$AUC, seq(0, 1, le = 11)))], main = NA)

vn0 %>%
  st_geometry() %>%
  plot(add = TRUE)
```
