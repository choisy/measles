---
title: "Explorations"
author: "Taishi Nakase"
date: "5/29/2020"
csl: the-american-naturalist.csl
output:
    html_document:
      theme: cerulean
      toc: yes
    pdf_document:
      toc: yes
bibligraphy: references.bib
editor_options:
  chunk_output_type: console 
---

<!--
IMAGES:
Insert them with: ![alt text](image.png)
You can also resize them if needed: convert image.png -resize 50% image.png
If you want to center the image, go through HTML code:
<div style="text-align:center"><img src ="image.png"/></div>

REFERENCES:
For references: Put all the bibTeX references in the file "references.bib"
in the current folder and cite the references as @key or [@key] in the text.
Uncomment the bibliography field in the above header and put a "References"
title wherever you want to display the reference list.
-->

<style type = "text/css">
.main-container {
  max-width: 1370px;
  margin-left: auto;
  margin-right: auto,
}
</style>

```{r general options, include = FALSE}
knitr::knit_hooks$set(
  margin = function(before, options, envir) {
    if (before) par(mgp = c(1.5, .5, 0), bty = "n", plt = c(.105, .97, .13, .97))
    else NULL
  },
  margin2 = function(before, options, envir) {
    if (before) par(mgp = c(1.5, .5, 0), bty = "n", plt = c(.105, .895, .13, .97))
    else NULL
  },
  prompt = function(before, options, envir) {
    options(prompt = if (options$engine %in% c("sh", "bash")) "$ " else "> ")
  })

knitr::opts_chunk$set(cache = TRUE, autodep = TRUE, message = FALSE, warning = FALSE,
                      margin = TRUE, dev.args = list(pointsize = 11), fig.height = 3.5,
                      fig.width = 4.24725, fig.retina = 2, fig.align = "center")

options(width = 137, scipen = 999)
```

## Packages

```{r}
required <- c("adaptivetau", "formula.tools", "purrr")
to_install <- setdiff(required, row.names(installed.packages()))
# if (length(to_install)) install.packages(to_install)
```

```{r}
library(magrittr)
library(ggplot2)
library(tidyverse)
library(iterpc)
library(deSolve)
library(R.utils)
```

## Single population stochastic model of measles epidemic
Consider a population of `N` individuals, of which `I0` are infections, `p` % are vaccinated and the rest are susceptible. The disease spreads in the population with an infectious contact rate of `beta` / person / time unit. Infected individuals remain in a latency period of mean duration `1 / sigma` time units before they become infectious from which state they recover at the rate of `gamma` / time unit. The following function runs stochastic individual-based simulations of this model for a duration of `tf` time units, using the algorithm coded in the `f` function. The algorithm implements adaptive tau leaping to approximate the trajectory of a continuous-time stochastic process (the Gillespie stochastic simulation algorithm). This model incorporates demographic stochasticity, which is defined as population processes that are driven by the random nature of events at the level of the individual. Furthermore, we consider the SEIR model; that is, the host can be categorized as suscepitble, infected but not yet infectious, infectious or recovered. 
<ul>
  <li>Infection occurs at rate $\beta \frac{SI}{N}. </li>
  <li>Getting infectious occurs at rate $\sigma E$. </li>
  <li>Recovery occurs at rate $\gamma I$. </li>
</ul>
Note that the model makes the assumption that the infection, getting infectious and recovery process are independent Poisson processes. 

```{r}
seir <- function(N = 1e6, I0 = 1, p = 0, beta = 5, sigma = 1/7, gamma = 1/7, 
                 tf = 100, f = adaptivetau::ssa.adaptivetau, ...) {
  vaccinated <- round(p * (N - I0))
  x0 <- c(S = N - I0 - vaccinated, E = 0, I = I0, R = vaccinated)
  transitions <- list(c(S = -1, E = +1),  # infection
                      c(E = -1, I = +1),  # getting infectious
                      c(I = -1, R = +1))  # recovery
  lvrates <- function(x, params, t) {with(c(x, params), 
                                          c(beta * S * I / N,
                                            sigma * E, 
                                            gamma * I))
  }
  data.frame(f(x0, transitions, lvrates, 
               list(beta = beta, sigma = sigma, gamma = gamma), tf = tf, ...))
}
```

Note that with the default parameter values, we have an $R_0$ of
$$
R_0 = \frac{\beta}{\sigma + \gamma} = \frac{5}{1/7 + 1/7} = 17.5
$$
Note that this $R_0$ is comparable to that of measles, which has an estimated $R_0$ of 16-18. Since $R_0$ is large, there is a restorative force that drives the population away from extinction whenever the number of infectious individuals is low. 

``` {r include = FALSE}
R_0 <- 17.5
```

Let's try it with default parameter values. 

```{r}
sim1 <- seir()
```

which gives, 

```{r}
head(sim1)
```

```{r}
sim1 %>% gather(key = state, value = number, S, E, I, R) %>%
  ggplot(aes(x = time, y = number, color = state, group = state)) + geom_line() + 
  labs(x = "Time (days)", y = "Prevalence")
```

### Running simulations in parallel

The following function runs any expression `expr` `n` times in parallel on `mc.cores`:

```{r}
mcreplicate <- function(n, expr, mc.cores = NULL) {
  if (is.null(mc.cores)) mc.cores <- parallel::detectCores() - 1
  parallel::mclapply(integer(n), eval.parent(substitute(function(...) expr)), mc.cores = mc.cores)
}
```

Let's try it:
``` {r}
sim2 <- mcreplicate(10, seir())
```

The following function plots the epi curves from a list of simulations:
```{r}
plot_list <- function(formula, ls, xlim = NULL, ylim = NULL, col = adjustcolor("black", 0.1), ...) {
  x <- purrr::map(ls, purrr::pluck, as.character(formula.tools::rhs(formula)))
  y <- purrr::map(ls, purrr::pluck, as.character(formula.tools::lhs(formula)))
  if (is.null(xlim)) xlim <- c(0, max(unlist(x)))
  if (is.null(ylim)) ylim <- c(0, max(unlist(y)))
  plot(NA, xlim = xlim, ylim = ylim, ...)
  purrr::walk2(x, y, lines, col = col)
}
```

Let's try it:
Plots the epi curves of 10 independent simulations. 
```{r}
plot_list(I ~ time, sim2, type = "l", xlab = "day", ylab = "prevalence")
```

Let's consider 1,000 simulations of the previous model for various vaccine coverages. For that, let's first consider the following `simulate()` function:

``` {r}
simulate <- function(x) purrr::rerun(1000, seir(p = x, tf = 1000))
```

Let's use this function in parallel for 11 values of vaccine coverage (1'):

```{r sim3}
sim3 <- parallel::mclapply(seq(0, 1, 0.1), simulate, mc.cores = parallel::detectCores() - 1)
```

Let's plot the $11 \times 1000 = 11000$ epi curves:
```{r}
plot_list(I ~ time, unlist(sim3, FALSE), type = "l", xlab = "day", ylab = "prevalence", xlim = c(0, 200))
```

### Probability of an epidemic and epidemic size with respect to vaccine coverage

The following function computes the average epidemic size in a population of 1,000,000 individuals, for a number of vaccine coverage values (in vector `p`) with `n` replications for each vaccine coverage value:
```{r}
avg_epi_size <- function(p = 0.5, N = 1e6, n = 1000, t = 0.1, nbcores = NULL, ...) {
  library(dplyr)
  if (is.null(nbcores)) nbcores <- parallel::detectCores() - 1
  simulate <- function(x) seir(p = x, N = N, ...)
  p %>% parallel::mclapply(function(x) purrr::rerun(n, dplyr::last(simulate(x)$R)), 
                                   mc.cores = nbcores) %>%
    purrr::map(function(x) data.frame(unlist(x))) %>%
    purrr::map(function(x) data.frame(mean(x$unlist.x))) %>%
    dplyr::bind_rows() %>%
    dplyr::transmute(p = p, avg_epi_size = as.integer(mean.x.unlist.x. - round(p * (N - 1))))
}
```

Let's try it (40''):
```{r sim4}
sim4 <- avg_epi_size(seq(0, 1, 0.1), tf = 1000)
```

```{r}
plot(avg_epi_size ~ p, sim4, xlab = "vaccine coverage", ylab = "epidemic size")
```

As expected, there is a negative correlation between vaccine coverage and epidemic size. In particular, there is a linear relationship between vaccine coverage and epidemic size. \newline

Let's see in more detail what happens between the vaccine coverage 80% and 100% (1'):

```{r sim5}
sim5 <- avg_epi_size(seq(0.8, 1, 0.01), tf = 1000)
```

Let's see that:

```{r}
plot(avg_epi_size ~ p, sim5, xlab = "vaccine coverage", ylab = "epidemic size")
abline(v = (1 - 1/R_0))
```
The vertical line shows the critical level of vaccination. 

The critical level of vaccination needed to eradicate an infectious disease $V_C$ is given by
$$
\begin{aligned}
  V_C = 1 - \frac{1}{R_0} = 1 - \frac{1}{17.5} \approx 0.9429
\end{aligned}
$$

Let's combine with previous simulation:

```{r}
plot(avg_epi_size ~ p, dplyr::bind_rows(sim4, sim5), 
     xlab = "vaccine coverage", ylab = "epidemic size")
```

and:

```{r}
plot(log10(avg_epi_size) ~ p, dplyr::bind_rows(sim4, sim5),
     xlab = "vaccine coverage", ylab = "epidemic size")
abline(h = log10(10))
abline(v = (1 - 1/R_0))
```

The horizontal line shows total number of secondary cases equal to 10. In what follows we will consider this (arbitrary) threshold value to define an epidemic. The following function uses this threshold to compute the probability that an epidemic occurs and the expected epidemic size in case there is an epidemic. 

```{r}
epi_proba_mean_size <- function(p = 0.5, I0 = 1, N = 1e6, n = 1000, t = 0.1, threshold = 10, 
                                nbcores = NULL, ...) {
  library(dplyr)
  if (is.null(nbcores)) nbcores <- parallel::detectCores() - 1
  simulate <- function(x) seir(p = x, N = N, ...)
  
  f <- function(x) {
    R_size <- unlist(purrr::rerun(n, dplyr::last(simulate(x)$R)))
    epi_size <- R_size - round(x * (N - 1))
    sel <- epi_size > threshold
    c(epi_proba = mean(sel),
      mean_epi_size = mean(epi_size[sel]))
  }
  
  p %>% 
    parallel::mclapply(f, mc.cores = nbcores) %>%
    purrr::map(~ t(.) %>% as.data.frame()) %>%
    purrr::map2(p, ~ dplyr::mutate(.x, p = .y)) %>%
    dplyr::bind_rows() %>%
    dplyr::select(p, dplyr::everything())
}
```

Let's try it (77'):

```{r sim6}
sim6 <- epi_proba_mean_size(seq(0, 1, 0.001), tf = 1000)
```

Let's see the effect of vaccine coverage on the probability of an epidemic. 

```{r margin = FALSE, margin2 = TRUE}
col1 <- "red"
col2 <- "blue"
plot(mean_epi_size ~ p, sim6, xlab = "vaccine coverage",
     ylab = NA, col = col1, axes = FALSE)
axis(1)
axis(2, col = col1, col.axis = col1)
title(ylab = "expected epidemic size", col.lab = col1)
par(new = TRUE)
plot(epi_proba ~ p, sim6, ann = FALSE, col = col2, axes = FALSE)
axis(4, col = col2, col.axis = col2)
mtext("probability of an epidemic", 4, 1.5, col = col2)
```

There is a strong linear relationship between vaccine coverage and the expected epidemic size. Furthermore, the effects of a decrease in vaccine coverage are particularly important for high vaccine coverages. Let's zoom up on the higher vaccine coverage region. 

```{r margin = FALSE, margin2 = TRUE}
sim6b <- dplyr::filter(sim6, p >= 0.7)

pc <- 1 - 1/R_0
tmp <- tail(dplyr::filter(sim6, p < round(pc, 3) + 0.001), 1)

col1 <- "red"
col2 <- "blue"
plot(mean_epi_size ~ p, sim6b, xlab = "vaccine coverage", ylab = NA, 
     col = col1, axes = FALSE)
axis(1)
axis(2, col = col1, col.axis = col1)
title(ylab = "expected epidemic size", col.lab = col1)
segments(0, tmp$mean_epi_size, pc, tmp$mean_epi_size, col = col1)
par(new = TRUE)
plot(epi_proba ~ p, sim6b, ann = FALSE, col = col2, axes = FALSE, ylim = 0:1)
axis(4, col = col2, col.axis = col2)
mtext("probability of an epidemic", 4, 1.5, col = col2)
segments(pc, tmp$epi_proba, 1.1, tmp$epi_proba, col = col2)
abline(v = pc)
```

Note that, at the theoretically safe vaccine coverage $p_c = 1 - 1/R_0 = 94.3 \%$, there is still a probability of `r tmp$epi_proba` to have an epidemic of `r round(tmp$mean_epi_size)` individuals.

### Epidynamics for varying population sizes
Let's simulate for other population sizes:

```{r sim7sim8sim9}
sim7 <- epi_proba_mean_size(seq(0, 1, 0.001), N = 1e5, tf = 1000)
sim8 <- epi_proba_mean_size(seq(0, 1, 0.001), N = 1e4, tf = 1000)
sim9 <- epi_proba_mean_size(seq(0, 1, 0.001), N = 1e3, tf = 1000)
```

Let's put the 4 simulations together. 
```{r}
four_sims <- dplyr::bind_rows(list(sim9, sim8, sim7, sim6), .id = "sim")
four_sims <- four_sims[sample(nrow(four_sims)), ] %>%
  dplyr::mutate(sim = as.integer(sim), 
                epi_size = mean_epi_size / (10^(sim + 2)))
```

Let's compare the probabilities of an epidemic for the 4 population sizes. 
```{r}
plot(epi_proba ~ p, four_sims, xlab = "vaccine coverage",
     ylab = "probability of an epidemic", col = four_sims$sim)
op <- par(family = "mono")
legend("center", legend = c("    1,000 ind.", "   10,000 ind.", "  100,000 ind.", "1,000,000 ind."),
       col = 1:4, pch = 1, bty = "n", title = "population size:")
par(op)
```

The probabilities of an epidemic for the 4 population sizes do not greatly differ across vaccine coverage levels. \newline

Let's now compare the expected epidemic size for the 4 population sizes:

```{r}
plot(epi_size ~ p, four_sims, xlab = "vaccine coverage",
     ylab = "expected proportion of population infected", col = 
       four_sims$sim)
op <- par(family = "mono")
legend("topright", legend = c("    1,000 ind.", "   10,000 ind.", "  100,000 ind.", "1,000,000 ind."),
       col = 1:4, pch = 1, bty = "n", title = "population size:", cex = 0.75)
par(op)
```

Let's zoom in:
```{r}
four_sims2 <- dplyr::filter(four_sims, p >= .93)
plot(epi_size ~ p, four_sims2, xlab = "vaccine coverage",
     ylab = "expected proportion of population infected", col = four_sims2$sim)
op <- par(family = "mono")
legend("topright", legend = c("    1,000 ind.", "   10,000 ind.", "  100,000 ind.", "1,000,000 ind."),
       col = 1:4, pch = 1, bty = "n", title = "population size:")
par(op)
```

The differences for the high vaccine coverage is an artefact of the chosen threshold on the number of 10 infected individuals chosen to define an epidemic. As such, populations of different sizes will have similar epidemic dynamics. 

In consequence, we'll use this data frame for our analyses. This provides a deterministic relationship between vaccine coverage and probability of epidemics in populations of arbitrary sizes. 
``` {r}
ref <- sim6 %>%
  dplyr::transmute(vacc_cov = p, 
                   epi_proba = epi_proba,
                   epi_prop = mean_epi_size / 1e6)
```

which looks like this:

```{r margin = FALSE, margin2 = TRUE}
ref2 <- dplyr::filter(ref, vacc_cov >= .7)
tmp2 <- tail(dplyr::filter(ref2, vacc_cov < round(pc, 3) + .001), 1)
plot((100 * epi_prop) ~ vacc_cov, ref2, xlab = "vaccine coverage",
     ylab = NA, col = col1, axes = FALSE)
axis(1)
axis(2, col = col1, col.axis = col1)
title(ylab = "percentage of total population affected", col.lab = col1)
segments(0, 100 * tmp2$epi_prop, pc, 100 * tmp2$epi_prop, col = col1)
par(new = TRUE)
plot(epi_proba ~ vacc_cov, ref2, ann = FALSE, col = col2, axes = FALSE, ylim = 0:1)
axis(4, col = col2, col.axis = col2)
mtext("probability of an epidemic", 4, 1.5, col = col2)
segments(pc, tmp2$epi_proba, 1.1, tmp2$epi_proba, col = col2)
abline(v = pc)
```

Again, at the recommended $V_c$ vaccine coverage calculated from $R_0$, there is stil more than a 50% chance to see an epidemic affecting more than 4% of the total population upon the introduction of one infected individual. 

### Probability of epidemic and number of initial infectives

The probability of an epidemic will depend on the number of infected individuals introduced in the population: \newline
The following computes the probability of an epidemics over different vaccine coverages and different initial infective levels. Furthermore, in keeping with an already established assumption, an epidemic is defined as the total number of secondary being in excess of 10. 

```{r}
epi_proba2 <- function(p = 1 - 1/17.5, I0 = 1, N = 1e6, n = 1000, t = 0.1, 
                       threshold = 10, ...) {
  simulate <- function(x, y) seir(p = x, I0 = y, N = N, ...)
  
  f <- function(x, y) {
    R_size <- unlist(purrr::rerun(n, dplyr::last(simulate(x, y)$R)))
    epi_size <- R_size - round(x * (N - y))
    sel <- epi_size > threshold
    c(mean(sel))
  }
  
  df <- data.frame("p" = p, 
                   do.call(cbind, 
                           purrr::map(I0, function(y) unlist(purrr::map(p, function(x) f(x, y))))))
  colnames(df) <- c("p", unlist(purrr::map(seq(1, length(I0)), function(x) c(paste0("I", x)))))
  df
}
```

Let's run this over a range of vaccine coverages and initial number of infectives. 

```{r}
epi_probs <- epi_proba2(p = seq(0, 1, 0.001), I0 = seq(1, 10, 1), tf = 1000, n = 1000)
```

Let's see how these epidemic probabilities compare to the approximate probabilities used in the first approximate model that is outlined in a section below. That is, 
$$
\begin{aligned}
  \text{Approximate probability of an epidemic} = 1 - (1 - p(v))^{I_0}
\end{aligned}
$$
where $p(v)$ is the probability of an epidemic starting from one infective in a population with vaccine coverage of $v\%$ and $I_0$ is the number of infectives introduced into the population. 

```{r}
est_epi_probs <- data.frame(sim6$p, do.call(cbind, purrr::map(seq(1, 10, 1), function(x) (1 - (1 - sim6$epi_proba)^x))))
diff <- data.frame("p" = sim6$p, do.call(cbind, purrr::map(seq(1, 10), function(x) as.matrix(epi_probs)[,x] - est_epi_probs[, x])))
```

```{r}
diff %>% gather(key = infectives, value = probability, X1:X10)  %>%
  ggplot(aes(x = p, y = probability, color = infectives, group = infectives)) + geom_line() + 
  labs(x = "vaccine coverage", y = "probability of an epidemic", title = "Diff. Actual and Approx.") +
  geom_vline(xintercept = 0.95)
```

At vaccine coverages greater than 95% (the black horizontal line), the actual probability of an epidemic is much larger than the estimated probability of an epidemic. Hence, for vaccine coverage levels greater than 95% the model for the probability of an epidemic in a population with $I_0$ initial infectives, which extrapolates from a population with one initial infective, no longer holds. 

## A Stochastic Population Network

### Two city stochastic SEIR model for measles epidemics (Rozhnova)
The number of individuals in the four classes belonging to city $j$ is denoted by $S_j, E_j, I_j$ and $R_j$ respetively. It is worth noting that the number of individuals belonging to any one city $N_j$ does not change with time. As such, the number of individuals belonging to city $j$ is given by $N_j = S_j + E_j + I_j + R_j$ for $j = 1, 2$. There are three types of transitions for each city. \newline
<ol>
  <li>Infected individual becoming infectious: For city j, this occurs at rate $\sigma E_j$. Result: $E_j \rightarrow E_j - 1$ and $I_j \rightarrow I_j + 1$. </li>
  <li>Recovery of an infective individual: For city j, this occurs at rate $\gamma I_j$. Result: $R_j \rightarrow R_j + 1$ and $I_j \rightarrow I_j - 1$. </li>
</ol>

The infectious process introduces transmission via out-of-city commuters. Let a fraction $f_{jk}$ denote the residents of city $k$ that commute to city $j$ where $j, k = 1,2$. Intuitively, $f_{jk}$ defines the average fraction of time an individual from city $k$ spends in city $j$. As such, the number of individuals in city $j$ is $M_j = (1 - f_{kj})N_j + f_{jk}N_k$, where $j \neq k$. \newline
Consider a susceptible individuals from city 1. There are four types of infective interations:
<ul>
  <li> infective residents in city 1 infect susceptible residents in city 1: $\beta(1 - f_{21})S_1(1 - f_{21})I_1 / M_1$
  <li> infective commuters from city 2 infect susceptible resident in city 1: $\beta(1 - f_{21})S_1 f_{12}I_2 / M_1$
  <li> infective residents in city 2 infect susceptible commuters from city 1: $\beta f_{21}S_1 (1 - f_{12})I_2 / M_2$
  <li> infective commuters from city 1 infect susceptible commuters from city 1 in city 2: $\beta f_{21} S_1 f_{21} I_1 / M_2$
</ul>

where $\beta$ is the parameter for the overall rate of infection. A similar analysis can be made for the susceptible individuals from city 2. 

3. Infection of a susceptible individual: For individual in city 1, this occurs at rate $\beta\left[c_{11} \frac{S_1 I_1}{N_1} + c_{12} \frac{S_1 I_2}{N_2}\right]$ and for individual in city 2, this occurs at rate $\beta\left[c_{21} \frac{S_2 I_1}{N_1} + c_{22} \frac{S_2 I_2}{N_2}\right]$. 

where 
$$
\begin{aligned}
  c_{11} & = \frac{(1 - f_{21})^2}{1 - f_{21} + f_{12}q} + \frac{f_{21}^2}{f_{21} + (1 - f_{12})q} \\
  c_{12} & = \frac{(1 - f_{21})f_{12}q}{1 - f_{21} + f_{12}q} + \frac{f_{21}(1 - f_{12})q}{f_{21} + (1 - f_{12})q} \\
  c_{21} & = \frac{(1 - f_{12}) f_{21}}{f_{21} + (1 - f_{12})q} + \frac{f_{12}(1 - f_{21})}{1 - f_{21} + f_{12}q} \\
  c_{22} & = \frac{(1 - f_{12})^2q}{f_{21} + (1 - f_{12})q} + \frac{f_{12}^2 q}{1 - f_{21} + f_{12}q} \\
\end{aligned}
$$
and $q = N_2 / N_1$. \newline

Consider two populations/cities. City 1 has `N1` individuals, of which `I10` are infections, `p1` % are vaccinated and the rest are susceptible. City 2 has `N2` individuals, of which `I20` are infections, `p2` % are vaccinated and the rest are susceptible. For both populations, the disease spreads in the population with an infectious contact rate of `beta` / person / time unit. Infected individuals remain in a latency period of mean duration `1 / sigma` time units before they become infectious from which state they recover at the rate of `gamma` / time unit. The following function runs stochastic individual-based simulations of this model for a duration of `tf` time units, using the algorithm coded in the `f` function. The algorithm implements adaptive tau leaping to approximate the trajectory of a continuous-time stochastic process (the Gillespie stochastic simulation algorithm). This model incorporates demographic stochasticity, which is defined as population processes that are driven by the random nature of events at the level of the individual. Furthermore, we consider the SEIR model; that is, the host can be categorized as susceptible, infected but not yet infectious, infectious or recovered. 

```{r}
seir2City <- function(N1 = 8e6, N2 = 1.5e6, I10 = 1, I20 = 1, p1 = 0, p2 = 0, 
                      beta = 5, sigma = 1/7, gamma = 1/7, f21 = 0.01, f12 = 0.05, 
                      tf = 100, f = adaptivetau::ssa.adaptivetau, ...) {
  q <- N2 / N1
  c11 <- (1 - f21)^2 / (1 - f21 + f12*q) + f21^2 / (f21 + (1 - f12)*q)
  c12 <- (1 - f21)*f12*q / (1 - f21 + f12*q) + f21*(1 - f12)*q / (f21 + (1 - f12)*q)
  c21 <- (1 - f12)*f21 / (f21 + (1 - f12)*q) + f12*(1 - f21) / (1 - f21 + f12*q) 
  c22 <- (1 - f12)^2 * q / (f21 + (1 - f12)*q) + f12^2 * q / (1 - f21 + f12*q) 
  vaccinated1 <- round(p1 * (N1 - 1))
  vaccinated2 <- round(p2 * (N2 - 1))
  x0 <- c(S1 = N1 - I10 - vaccinated1, E1 = 0, I1 = I10, R1 = vaccinated1,
          S2 = N2 - I20 - vaccinated2, E2 = 0, I2 = I20, R2 = vaccinated2)
  transitions <- list(c(S1 = -1, E1 = +1),  # infection
                      c(E1 = -1, I1 = +1),  # getting infectious
                      c(I1 = -1, R1 = +1),  # recovery
                      c(S2 = -1, E2 = +1),  # infection
                      c(E2 = -1, I2 = +1),  # getting infectious
                      c(I2 = -1, R2 = +1))  # recovery
  lvrates <- function(x, params, t) {
    rates1 <- with(c(x, params), c(beta * (c11 * S1 * I1 / N1 + c12 * S1 * I2 / N2),
                                   sigma * E1, gamma * I1))
    rates2 <- with(c(x, params), c(beta * (c21 * S2 * I1 / N1 + c22 * S2 * I2 / N2),
                                   sigma * E2, gamma * I2))
    c(rates1, rates2)
  }
  data.frame(f(x0, transitions, lvrates, 
               list(beta = beta, sigma = sigma, gamma = gamma), tf = tf, ...))
}
```

#### Explorations of the two city model
For the following two-city explorations, we will consider a large city of 8 million people and a smaller provincial city of 1 million. Furthermore, we will assume that the number of people that travel from the large city to the small city is relatively small and fixed, whereas the number of people that travel from the small city to the large city is variable. \newline
 
First, suppose that the large city has a relatively high vaccine coverage in comparison to the smaller city. We will explore how the epidemic dynamics in the large population change with increasing demographic coupling between the two cities. The following function computes the probability of an epidemic for the large city in a two-city model over different levels of coupling between the two cities. Note that will still define an epidemic as at least 10 secondary infections. 
```{r}
epi_proba_mean_size3 <- function(N1 = 8e6, N2 = 1e6, I10 = 1, I20 = 1, p1 = 0.95, p2 = 0.75,
                                 f21 = 0.01, f12 = 0.01, n = 10000, t = 0.1, threshold = 10, 
                                 nbcores = NULL, ...) {
  library(dplyr)
  if (is.null(nbcores)) nbcores <- parallel::detectCores() - 1
  simulate <- function(x) seir2City(N1 = N1, N2 = N2, I10 = I10, I20 = I20, p1 = p1, p2 = p2,
                                    f21 = f21, f12 = x,...)
  
  f <- function(x) {
    R_size <- unlist(purrr::rerun(n, dplyr::last(simulate(x)$R1)))
    epi_size <- R_size - round(p1 * (N1 - 1))
    sel <- epi_size > threshold
    c(epi_proba = mean(sel),
      mean_epi_size = mean(epi_size[sel]))
  }
  f12 %>% 
    parallel::mclapply(f, mc.cores = nbcores) %>%
    purrr::map(~ t(.) %>% as.data.frame()) %>%
    purrr::map2(f12, ~ dplyr::mutate(.x, f12 = .y)) %>%
    dplyr::bind_rows() %>%
    dplyr::select(f12, dplyr::everything())
}
```

Let's simulate this hypothetical two-city network. 
```{r eval = FALSE}
sim12 <- epi_proba_mean_size3(f12 = seq(0, 0.20, 0.01), f21 = 0.00001, tf = 1000)
```

Let's see how the probability of an epidemic and the mean epidemic size given an epidemic occurs change with increasing coupling between the two cities. 
```{r margin1 = FALSE, margin2 = TRUE, eval = FALSE}
col1 <- "red"
col2 <- "blue"
plot(mean_epi_size ~ f12, sim12, xlab = "demographic coupling", ylab = NA, 
     col = col1, axes = FALSE)
axis(1)
axis(2, col = col1, col.axis = col1)
title(ylab = "expected epidemic size", col.lab = col1)
par(new = TRUE)
plot(epi_proba ~ f12, sim12, ann = FALSE, col = col2, axes = FALSE)
axis(4, col = col2, col.axis = col2)
mtext("probability of an epidemic", 4, 1.5, col = col2)
```

As the demographic coupling, measured by the fraction of residents of the smaller provincial city that commute to the larger city, increases the expected epidemic size and the probability of an epidemic in the larger city increases. \newline

Now, suppose that the demographic coupling between the two cities is fixed with $f_{21} = 0.001$ and $f_{12} = 0.1$. The vaccine coverage in the large city is relatively high at $95\%$, whereas the vaccine coverage in the smaller city is variable. We will explore how the epidemic dynamics in the large population change with varying vaccination coverage in the smaller city. 

```{r}
epi_proba_mean_size4 <- function(N1 = 8e6, N2 = 1e6, I10 = 1, I20 = 1, p1 = 0.95, p2 = 0.75,
                                 f21 = 0.01, f12 = 0.1, n = 1000, t = 0.1, threshold = 10, 
                                 nbcores = NULL, ...) {
  library(dplyr)
  if (is.null(nbcores)) nbcores <- parallel::detectCores() - 1
  simulate <- function(x) seir2City(N1 = N1, N2 = N2, I10 = I10, I20 = I20, p1 = p1, p2 = x,
                                    f21 = f21, f12 = f12,...)
  
  f <- function(x) {
    R_size <- unlist(purrr::rerun(n, dplyr::last(simulate(x)$R1)))
    epi_size <- R_size - round(p1 * (N1 - 1))
    sel <- epi_size > threshold
    c(epi_proba = mean(sel),
      mean_epi_size = mean(epi_size[sel]))
  }
  p2 %>% 
    parallel::mclapply(f, mc.cores = nbcores) %>%
    purrr::map(~ t(.) %>% as.data.frame()) %>%
    purrr::map2(p2, ~ dplyr::mutate(.x, p2 = .y)) %>%
    dplyr::bind_rows() %>%
    dplyr::select(p2, dplyr::everything())
}
```

Let's simulate this hypothetical two-city network. 
```{r eval = FALSE}
sim13 <- epi_proba_mean_size4(p2 = seq(0, 1, 0.01) , tf = 1000)
```

```{r margin1 = FALSE, margin2 = TRUE, eval = FALSE}
col1 <- "red"
col2 <- "blue"
plot(mean_epi_size ~ p2, sim13, xlab = "vaccination coverage in smaller city", ylab = NA, 
     col = col1, axes = FALSE)
axis(1)
axis(2, col = col1, col.axis = col1)
title(ylab = "expected epidemic size", col.lab = col1)
par(new = TRUE)
plot(epi_proba ~ p2, sim13, ann = FALSE, col = col2, axes = FALSE)
axis(4, col = col2, col.axis = col2)
mtext("probability of an epidemic", 4, 1.5, col = col2)
```


### N city stochastic SEIR model for measles epidemics (Rozhnova)
Again, the number of individuals in the four classes belonging to city $j$ is denoted by $S_j, E_j, I_j$ and $R_j$ respetively. The number of individuals belonging to city $j$ is given by $N_j = S_j + E_j + I_j + R_j$ for $j \in \{1,2,\ldots,n\}$. There are three types of transitions for each city. \newline
<ol>
  <li>Infected individual becoming infectious: For city j, this occurs at rate $\sigma E_j$. Result: $E_j \rightarrow E_j - 1$ and $I_j \rightarrow I_j + 1$. </li>
  <li>Recovery of an infective individual: For city j, this occurs at rate $\gamma I_j$. Result: $R_j \rightarrow R_j + 1$ and $I_j \rightarrow I_j - 1$. </li>
</ol>

The derivation of the rate of infection is analogous to that of the two city model. Let a fraction $f_{jk}$ denote the residents of city $k$ that commute to city $j$ where $j, k \in \{1,2,\ldots, n\}$. Intuitively, $f_{jk}$ defines the average fraction of time an individual from city $k$ spends in city $j$. To ease notation consider the quantity
$$
\begin{aligned}
  f_j = \sum_{k \neq j} f_{kj}
\end{aligned}
$$
which denotes the fraction of residents of city $j$ that are in a different city at any given point in time. As such, the number of individuals in city $j$ is 
$$
\begin{aligned}
  M_j = (1 - f_j) N_j + \sum_{k \neq j} f_{jk} N_k
\end{aligned}
$$
Again, consider a susceptible individuals from city 1. There are four types of infective interations:
<ul>
  <li> infective residents in city 1 infect susceptible residents in city 1: $\beta(1 - f_1)S_1(1 - f_1)I_1 / M_1$
  <li> infective commuters from city 2 infect susceptible resident in city 1: $\beta(1 - f_1)S_1 \sum_{j \neq 1} f_{1j} I_j / M_1$
  <li> infective residents in city 2 infect susceptible commuters from city 1: $\beta \sum_{j \neq 1} (1 - f_j) I_j f_{j1} S_1 / M_j$
  <li> infective commuters from city 1 infect susceptible commuters from city 1 in city 2: $\beta \sum_{j \neq 1} f_{j1} S_1 \sum_{k \neq j} f_{jk} I_k / M_j$
</ul>
where $\beta$ is the parameter for the overall rate of infection. A similar analysis can be made for the susceptible individuals of all the remaining cities. 

3. Infection of a susceptible individual: For individual in city $j$, this occurs at rate
$$
\begin{aligned}
  \beta \sum_{k=1}^n c_{jk} \frac{S_j I_k}{N_k}
\end{aligned}
$$
where 
$$
\begin{aligned}
c_{jj} = \frac{(1 - f_j)^2 N_j}{\left[(1 - f_j)N_j + \sum_{m\neq j} f_{jm} N_m \right]} + \sum_{l \neq j} \frac{f_{lj}^2 N_j}{\left[(1 - f_l)N_l + \sum_{m \neq l} f_{lm} N_m\right]} 
\end{aligned}
$$
for $j = 1, \ldots, n$ and 
$$
\begin{aligned}
c_{jj} = \frac{(1 - f_j)f_{jk} N_k}{\left[(1 - f_j)N_j + \sum_{m\neq j} f_{jm} N_m \right]} + \frac{(1 - f_k)f_{kj} N_k}{\left[(1 - f_k)N_k + \sum_{m\neq k} f_{km} N_m \right]} + \sum_{l \neq j,k} \frac{f_{lj}f_{lk} N_k}{\left[(1 - f_l)N_l + \sum_{m \neq l} f_{lm} N_m\right]} 
\end{aligned}
$$
for $j, k = 1,\ldots,n$ and $j \neq k$. 
\newline

The following function implements the above model. \newline
Consider `num` populations/cities. City j has `N[j]` individuals, of which `I[j]` are infections, `p[j]` % are vaccinated and the rest are susceptible. For all populations, the disease spreads in the population with an infectious contact rate of `beta` / person / time unit. Infected individuals remain in a latency period of mean duration `1 / sigma` time units before they become infectious from which state they recover at the rate of `gamma` / time unit. `f` is the demographic coupling matrix among the `n` cities where $f_{jj} = 1 - \sum_{k \neq j} f_{kj}$. The following function runs stochastic individual-based simulations of this model for a duration of `tf` time units, using the algorithm coded in the `f` function. The algorithm implements adaptive tau leaping to approximate the trajectory of a continuous-time stochastic process (the Gillespie stochastic simulation algorithm).

```{r}
seirNCity <- function(num = 2, N = c(8e6, 1.5e6), I0 = c(1,1), p = c(0, 0),
                      beta = 5, sigma = 1/7, gamma = 1/7, 
                      fM = matrix(c(0.99, 0.01, 0.05, 0.95), nrow = 2, ncol = 2, byrow = FALSE),
                      tf = 100, f = adaptivetau::ssa.adaptivetau, ...) {
  
  # vector of initial values
  vaccinated <- unlist(purrr::map2(p, N, function(x, y) round(x * (y - 1))))
  x0 <- unlist(purrr::pmap(list(I0, vaccinated, N), function(x, y, z) c(z - x - y, 0, x, y)))
  names(x0) <- unlist(purrr::map(seq(1, num), function(x) c(paste0("S", x), paste0("E", x),
                                                   paste0("I", x), paste0("R", x))))
  
  # Transitions
  varNames1 <- unlist(purrr::map(seq(1, num), function(x) c(paste0("S", x), paste0("E", x),
                                                   paste0("I", x))))
  varNames2 <- unlist(purrr::map(seq(1, num), function(x) c(paste0("E", x), paste0("I", x),
                                                   paste0("R", x))))
  fTransitions <- function(x, y) {
    tmp <- c(-1, +1)
    names(tmp) <- c(x, y)
    tmp
  }
  transitions <- purrr::map2(varNames1, varNames2, fTransitions)
  
  # City commmuter coefficients. 
  f2 <- function(j, k) {
    if (j == k) {
        return(fM[j,j]^2 * N[j] / (fM[j,k] * N[j] + sum((t(N * t(fM))[j,])[-j])) +
                 sum(unlist(purrr::map(seq(1:num)[-j], 
                                       function(x) (fM[x,j]^2 * N[j] / 
                                                      (fM[x,x] * N[x] + sum(((t(N * t(fM))[x,])[-x]))))))))
      }
      if (j != k) {
        return(fM[j,j] * fM[j,k] * N[k] / (fM[j,j] * N[j] + sum((t(N * t(fM))[j,])[-j])) + 
                 fM[k,j] * fM[k,k] * N[k] / (fM[k,k] * N[k] + sum((t(N * t(fM))[k,])[-k])) + 
                 sum(unlist(purrr::map(seq(1:num)[-c(j,k)], 
                                       function(x) (fM[x,j] * fM[x,k] * N[k] /
                                                      (fM[x,x] * N[x] + sum((t(N * t(fM))[x,])[-x])))))))

      }
  }
  I <- iterpc(num, 2, ordered = TRUE, replace = TRUE)
  coeffs <- unlist(purrr::map2(t(getall(I))[1,], t(getall(I))[2,], f2))
  cMatrix <- matrix(coeffs, nrow = num, ncol = num, byrow = TRUE)
  
  # rate function.
  lvrates <- function(x, params, t){
    cityRates <- function(j) {
    infectionRate <- 
      sum(unlist(purrr::map(seq(1, num), 
                            function(k) cMatrix[j, k] * x[paste0("S", j)] * x[paste0("I", k)] / N[k])))
    with(c(x, params), c(beta * infectionRate, sigma * x[paste0("E", j)], gamma * x[paste0("I", j)]))
    }
    unlist(purrr::map(seq(1, num), cityRates))
  }
  
  # simulation
  data.frame(f(x0, transitions, lvrates, 
               list(beta = beta, sigma = sigma, gamma = gamma), tf = tf, ...))
}
```

Let's try the model over two cities. 
```{r}
sim2City <- seirNCity(num = 2, N = c(1e6, 1e6), 
                      p = c(0.95, 0.5), I0 = c(1, 1),
                      fM = matrix(c(0.098, 0.002, 0.1, 0.9),
                                 nrow = 2, ncol = 2, byrow = FALSE))
```

which gives, 

```{r}
head(sim2City)
```

```{r}
library(dplyr)
sim2City %>% dplyr::select(time, I1, I2) %>%
  gather(key = city, value = number, I1, I2) %>%
  ggplot(aes(x = time, y = number, color = city, group = city)) + geom_line() + 
  labs(x = "Time (days)", y = "Prevalence")
```

Now, let's try the model over three cities. 

``` {r}
sim3City <- seirNCity(num = 3, N = c(1e6, 1e6, 1e6), 
                      p = c(0.95, 0.5, 0.95), I0 = c(1, 0, 0),
                      fM = matrix(c(0.098, 0.001, 0.001, 0.1, 0.9, 0, 0.1, 0, 0.9), 
                                 nrow = 3, ncol = 3, byrow = FALSE), tf = 150)
```

which gives 

```{r}
head(sim3City)
```

```{r}
library(dplyr)
sim3City %>% dplyr::select(time, I1, I2, I3) %>%
  gather(key = city, value = number, I1, I2, I3) %>%
  ggplot(aes(x = time, y = number, color = city, group = city)) + geom_line() + 
  labs(x = "Time (days)", y = "Prevalence")
```

The demographic coupling parameters for the above three city model were selected such that there was strong coupling between city 1 and city 2 and relatively no coupling between city 2 and city 3. Furthermore, the vaccination coverage in city 2 is lower relative to cities 1 and 3. As such, one would expect that there would be a large epidemic in city 2, as well as a small epidemic in city 1 and relatively no infections in city 3. This is precisely what one observes in the above graph. 

#### Explorations of the N-city model
Consider a large central city of 8 million people and two smaller satellite cities each with 1 million residents. Furthermore, suppose that the large city has a relatively high vaccine coverage in comparison to the two smaller cities. We will explore how the epidemic dynamics in the central change vary with different vaccine coverage levels in the satellite cities. 

```{r}
epi_proba_mean_size5 <- function(num = 3, N = c(8e6, 1e6, 1e6), I0 = c(0, 1, 1), 
                                 p = list(0.95, 0.5, 0.5), 
                                 fM = matrix(c(0.098, 0.001, 0.001, 0.1, 0.9, 0, 0.1, 0, 0.9),
                                         nrow = 3, ncol = 3, byrow = FALSE),
                                 n = 1000, t = 0.1, threshold = 10, 
                                 nbcores = NULL, ...) {
  library(dplyr)
  simulate <- function(x, y) seirNCity(num = num, N = N, I0 = I0, p = c(p[[1]], x, y),
                                    fM = fM, ...)
  
  f <- function(x, y) {
    R_size <- unlist(purrr::rerun(n, dplyr::last(simulate(x, y)$R1)))
    epi_size <- R_size - round(p[[1]] * (N[1] - 1))
    sel <- epi_size > threshold
    c(epi_proba = mean(sel),
      mean_epi_size = mean(epi_size[sel]))
  }
  purrr::map2(p[[2]], p[[3]], f) %>%
  purrr::map(~ t(.) %>% as.data.frame()) %>%
  dplyr::bind_rows() %>%
  dplyr::mutate(p2 = p[[2]], p3 = p[[3]]) %>%
  dplyr::select(p2, p3, dplyr::everything())
}
```

```{r, eval = FALSE}
sim14 <- epi_proba_mean_size5(num = 3, N = c(8e6, 1e6, 1e6), I0 = c(1, 1, 1),
                              p = list(0.95, seq(0, 1, 0.01), seq(0, 1, 0.01)),
                              f = matrix(c(0.098, 0.001, 0.001, 0.1, 0.9, 0, 0.1, 0, 0.9),
                                         nrow = 3, ncol = 3, byrow = FALSE),
                                    tf = 1000)
```

```{r margin1 = FALSE, margin2 = TRUE, eval = FALSE}
col1 <- "red"
col2 <- "blue"
plot(mean_epi_size ~ p2, sim14, xlab = "vaccination coverage in satellite cities", ylab = NA, 
     col = col1, axes = FALSE)
axis(1)
axis(2, col = col1, col.axis = col1)
title(ylab = "expected epidemic size", col.lab = col1)
par(new = TRUE)
plot(epi_proba ~ p2, sim14, ann = FALSE, col = col2, axes = FALSE)
axis(4, col = col2, col.axis = col2)
mtext("probability of an epidemic", 4, 1.5, col = col2)
```

## A Deterministic/Stochastic Population Network: Model 1

### Deterministic SEIR model
Consider a population of `N` individuals with `Y0` initial infectives and `v`% vaccine coverage. The epidynamics of the population will be simulated by a deterministic SEIR model without demographic over a time frame `tf` days. The parameters are given by a transmission rate of `beta`, an average latency period of `1 / sigma` days and an average recovery period of `1 / gamma` days. <br>
The system of differential equations that characterize this deterministic model are given by:
$$
\begin{aligned}
  \frac{dX}{dt} & = - \beta \frac{XY}{N} \\
  \frac{dW}{dt} & = \beta \frac{XY}{N} - \sigma W \\
  \frac{dY}{dt} & = \sigma W - \gamma Y \\
  \frac{dR}{dt} & = \gamma Y \\
\end{aligned}
$$
where $X, W, Y, Z$ are the number of susceptibles, infected but not infectious, infected and recovered individuals in the population. 

```{r}
dseir <- function(N = 1e6, Y0 = 1, v = 0, beta = 5, sigma = 1/7, gamma = 1/7, 
                 tf = 100, ...) {
  vaccinated <- round(v * (N - Y0))
  x0 <- c(X = N - Y0 - vaccinated, W = 0, Y = Y0, Z = vaccinated)
  parameters <- c(beta = beta, sigma = sigma, gamma = gamma)
  f <- function(t, state, parameters) {
    with(as.list(c(state, parameters)), {
      # rate of change
      dX = -beta * X * Y / N
      dW = beta * X * Y / N - sigma * W
      dY = sigma * W - gamma * Y
      dZ = gamma * Y 
      
      # rate the rate of change
      list(c(dX, dW, dY, dZ))
      })
  }
  times <- seq(0, tf, by = 1)
  as.data.frame(ode(y = x0, times = times, func  = f, 
                              parms = parameters))
}
```

Let's run this deterministic SEIR with the default parameters. 
```{r}
dseir1 <- dseir(v = 0.95, tf = 365)
ggplot(dseir1, aes(x = time, y = Y)) + geom_line() +
  labs(x = "time (days)", y = "Prevalence")
```

Let's see how this compares to the stochastic SEIR model with analogous parameters
```{r}
set.seed(20)
sseir1 <- seir(N = 1e6, I0 = 1, p = 0.95, beta = 5, sigma = 1/7, gamma = 1/7, tf = 365)
plot(I ~ time, sseir1, xlab = "time (days)", ylab = "prevalance", col = "red", type = "l")
par(new = TRUE)
plot(Y ~ time, dseir1, ann = FALSE, axes = FALSE, col = "blue", type = "l")
legend("topright", legend = c("Deterministic", "Stochastic"), col = c("blue","red"), pch = 1,  
       bty = "n",cex = 0.50)
```

The prevalence curves for the single population deterministic and stochastic models are consistent. Note that to make this statement more rigorous, we would have the simulate both models a number of times to derive an average behavior. Over numerous simulations, however, the above relationship holds so for brevity only one simulation is included. 

### Numerical approximation of the relationship between probability of epidemic and vaccine coverage
We defined an epidemic as 10 or more secondary infections. We used this threshold to compute the probability that an epidemic occurs and the expected epidemic size in case there is an epidemic in a population of 1,000,000 individuals when a single infective is introduced. 

```{r margin = FALSE, margin2 = TRUE}
col1 <- "red"
col2 <- "blue"
plot(mean_epi_size ~ p, sim6, xlab = "vaccine coverage",
     ylab = NA, col = col1, axes = FALSE)
axis(1)
axis(2, col = col1, col.axis = col1)
title(ylab = "expected epidemic size", col.lab = col1)
par(new = TRUE)
plot(epi_proba ~ p, sim6, ann = FALSE, col = col2, axes = FALSE)
axis(4, col = col2, col.axis = col2)
mtext("probability of an epidemic", 4, 1.5, col = col2)
```

We would like to numerically approximate the above relationship between the probability of an epidemic and vaccine coverage. The following uses a natural cubic spline with 30 degrees of freedom to fit the model. 
```{r}
y1 <- smooth.spline(x = sim6$p, y = sim6$epi_proba)
vaccineValues <- data.frame(p = seq(0, 1, 0.01))
fit <- predict(y1, x = vaccineValues)
plot(epi_proba ~ p, sim6, pch=16)
lines(fit$x$p, fit$y$p,lwd=2, col = "red", xlab = "vaccine coverage", ylab = "probability of an epidemic")
```

As expected, the natural spline is a good fit to the data points. This function, as given by the red curve, will be used to estimate the probability that a population has an epidemic on any given day when there is a single infective introduced into the population. Furthermore, it was illustrated in some of the single population explorations above that the probability of an epidemic across different vaccine coverages is largely independent of population size. As such, this function can be used for different population sizes without modification. 

### Approximate N-city model 
There are `n` cities in the network each with population size and vaccine coverage given by vectors `N` and `v` respectively. The number of initial infectives in each city is `Y0`. Furthermore, the strength of association between the two cities is given by $\rho_{21}$ and $\rho_{12}$, where $\rho_{ij}$ denotes the coupling from city $j$ to city $i$.

```{r}
nCityApprox <- function(n = 2, N = c(1e6, 1e6), v = c(0.95, 0.95), Y0 = c(1, 0),
                          rho = matrix(c(0.99, 0.01, 0.01, 0.99), nrow = 2, ncol = 2, byrow = FALSE), 
                          tf = 365) {
  
 # Probability of epidemic for all populations starting with a single infective
 epi_prob <- predict(y1, x = data.frame(v))$y$v
 
 # Generate prevalence curves for infected populations
  f1 <- function(x, y) {
    if (x == 0)
      return (rep(0, tf+1))
    else
      return (dseir(N = N[y], Y0 = Y0[y], v = v[y], tf = tf)$Y)
  }
  I <- purrr::map2(Y0, seq(1, n), f1)
  I <- do.call(cbind, I)
  
  # Run the simulation over the specified time frame. 
  for(t in 1:tf) {
    for(i in which(I[t, ] == 0)) {
      prob <- 1 - (1 - epi_prob[i])^(sum(I[t, ] * rho[, i]))
      if (runif(1, 0, 1) < prob) {
        I[, i] <- c(rep(0, t), dseir(N = N[i], Y0 = sum(I[t, ] * rho[, i]), v = v[i], tf = tf - t)$Y)
      }
    }
  }
  I <- as.data.frame(I) %>% mutate("time" = 1:(tf+1)) %>% select("time", dplyr::everything())
  colnames(I) <- c("time", unlist(purrr::map(seq(1, n), function(x) c(paste0("I", x)))))
  I
}
```

Let's run this approximate model with the following parameters. 
```{r}
sim15 <- nCityApprox(n = 2, N = c(1e6, 1e6), v = c(0.95, 0.5), 
                     Y0 = c(0, 1), tf = 400, 
                     rho = matrix(c(0.98, 0.02, 0.1, 0.9), nrow = 2, ncol = 2, byrow = FALSE))
```

```{r}
plot1 <- sim15 %>% gather(key = population, value = number, I1, I2) %>% 
  ggplot(aes(x = time, y = number, color = population, group = population)) + geom_line() + 
  labs(x = "Time (days)", y = "Prevalence", title = "Approximate Model")
```

Let's compare this approximate model with exact stochastic model 
```{r}
sim2City <- seirNCity(num = 2, N = c(1e6, 1e6), 
                      p = c(0.95, 0.5), I0 = c(0, 1),
                      fM = matrix(c(0.098, 0.02, 0.1, 0.9),
                                 nrow = 2, ncol = 2, byrow = FALSE))
```

```{r}
plot2 <- sim2City %>% dplyr::select(time, I1, I2) %>%
  gather(key = population, value = number, I1, I2) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) + geom_line() + 
  labs(x = "Time (days)", y = "Prevalence", title = "Exact Model")
```

```{r}
plot1
plot2
```

The prevalence curves for population 1 for both the exact stochastic model and the approximate model show similar dynamics with comparable peak epidemic sizes and shapes. The prevalence curves for population 2 between the two models, however, are noticably different. it takes far longer for epidemic in population 2 in the approximate model to reach its peak size in comparison with that of the exact model. In particular, for population 2 in the approximate model, it takes about `r sim15[which(sim15$I1 >= 1), 1][1]` days to get 1 infected individual and about `r sim15[which(sim15$I1 >= 10), 1][1]` days to get 10 infected individuals. In comparison, for population 2 in the exact model, it takes about `r sim2City[which(sim2City$I1 == 1), 1][1]` days to get 1 infected individual and about `r sim2City[which(sim2City$I1 >= 10), 1][1]` days to get 10 infected individuals. This suggests that the epidemic spreads far quicker in population 2 in the exact model compared to that of the approximate model. In the approximate model, it was assumed that once an epidemic starts it is not influenced by coupling with different areas; that is, within population epidynamics are deterministic but between population dynamics are stochastic. It is this assumption that most likely accounts for the discrepency because the approximate model fails to account for the strong force of infection presented by neighboring populations when the epidemic is evolving. As such, it is necessary to account for this coupling in within population epidynamics. 

For completeness, let's consider a slightly more complex model with three populations.
```{r}
sim16 <- nCityApprox(n = 3, N = c(1e6, 1e6, 1e6), 
                       v = c(0.95, 0.5, 0.95), Y0 = c(0, 1, 0),
                       rho = matrix(c(0.998, 0.001, 0.001, 0.1, 0.9, 0, 0.1, 0, 0.9), 
                                 nrow = 3, ncol = 3, byrow = FALSE), tf = 700)
```

```{r}
plot3 <- sim16 %>% gather(key = population, value = number, I1, I2, I3) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) +
  geom_line() + labs(x = "Time (days)", y = "Prevalence", title = "Approximate Model") +
  xlim(0, 400)
```

Let's compare this approximate model with exact stochastic model.
``` {r}
sim3City <- seirNCity(num = 3, N = c(1e6, 1e6, 1e6), 
                      p = c(0.95, 0.5, 0.95), I0 = c(0, 1, 0),
                      fM = matrix(c(0.998, 0.001, 0.001, 0.1, 0.9, 0, 0.1, 0, 0.9), 
                                 nrow = 3, ncol = 3, byrow = FALSE), tf = 150)
```

```{r}
plot4 <- sim3City %>% dplyr::select(time, I1, I2, I3) %>%
  gather(key = population, value = number, I1, I2, I3) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) +
  geom_line() + labs(x = "Time (days)", y = "Prevalence", title = "Exact Model")
```

```{r}
plot3
plot4
```

There are also noticiable lags in the approximate model compared to the exact stochastic model.


## Second Approximation of the Population Network
The following approximation of the exact stochastic model attempts to account for the lag effects that were observed in the first approximate model by deterministically coupling populations that are experiencing epidemics. Rozhnova's coupling constants are also employed to account for all possible modes of transmission between neighboring populations. 

### Two population model (hard coded)
The epidynamics of the two coupled populations will be simulated by a deterministic SEIR metapopulation model without demographic over a time frame tf days. The parameters are given by a transmission rate of `beta`, an average latency period of `1 / sigma` days and an average recovery period of `1 / gamma` days. 
The system of differential equations that characterize this deterministic model are given by:
$$
\begin{aligned}
  \frac{dX_1}{dt} & = - \beta \left(c_{11} \frac{X_1 Y_1}{N_1} + c_{12} \frac{X_1 Y_2}{N_2} \right) \\
  \frac{dW_1}{dt} & = \beta \left(c_{11} \frac{X_1 Y_1}{N_1} + c_{12} \frac{X_1 Y_2}{N_2} \right)  - \sigma W_1 \\
  \frac{dY_1}{dt} & = \sigma W_1 - \gamma Y_1 \\
  \frac{dR_1}{dt} & = \gamma Y_1 \\
  \frac{dX_2}{dt} & = - \beta \left(c_{21} \frac{X_2 Y_1}{N_1} + c_{22} \frac{X_2 Y_2}{N_2} \right) \\
  \frac{dW_2}{dt} & = \beta \left(c_{11} \frac{X_2 Y_1}{N_1} + c_{12} \frac{X_2 Y_2}{N_2} \right)  - \sigma W_2 \\
  \frac{dY_2}{dt} & = \sigma W_2 - \gamma Y_2 \\
  \frac{dR_2}{dt} & = \gamma Y_2 \\
\end{aligned}
$$
where $X, W, Y, Z$ are the number of susceptible, infected but not infectious, infected and recovered individuals in the population respectively. The coupling coefficients are given by the matrix `c` and are the same as those in the exact stochastic model. <br>

Computes the epidynamics of two populations over `tf` days with a disease parametetrised by a `beta` transmission rate per capita, a latency period of `1 / sigma` days and a recovery period of `1 / gamma` days. Furthermore, each population is initialized with  `X0` susceptibles, `W0` infected but not infectious individuals, `Y0` infectives and `Z0` recovered individuals. The populations are coupled according to the 2-by-2 matrix `cMatrix`. It returns a list of length 2 with each element a dataframe with columns `time`, `X`, `W`, `Y`, `Z` that describe the dynamics of the epidemic over time. Note that the pre-computed coupling matrix must be provided; it will not be computed by the function itself. 
```{r dseir2}
dseir2 <- function(X0 = c(1e6, 1e6), W0 = c(0, 0), Y0 = c(1, 1), Z0 = c(0, 0),
                   beta = 5, sigma = 1/7, gamma = 1/7, 
                   cMatrix, tf = 100, ...) {
  
  # Initialization of variables
  N <- c(X0[1] + W0[1] + Y0[1] + Z0[1], X0[2] + W0[2] + Y0[2] + Z0[2])
  x0 <- c(X1 = X0[1], W1 = W0[1], Y1 = Y0[1], Z1 = Z0[1], 
          X2 = X0[2], W2 = W0[2], Y2 = Y0[2], Z2 = Z0[2])

  # Parameter vector
  parameters <- c(beta = beta, sigma = sigma, gamma = gamma, N = N, cMatrix = cMatrix)
  
  # Returns the set of differential rate functions. 
  f <- function(t, state, parameters) {
    with(as.list(c(state, parameters)), {
      # rate of change
      dX1 = - beta * (cMatrix[1,1] * X1 * Y1 / N[1] + cMatrix[1,2] * X1 * Y2 / N[2])
      dW1 = beta * (cMatrix[1,1] * X1 * Y1 / N[1] + cMatrix[1,2] * X1 * Y2 / N[2]) - sigma * W1
      dY1 = sigma * W1 - gamma * Y1
      dZ1 = gamma * Y1
      dX2 = - beta * (cMatrix[2,1] * X2 * Y1 / N[1] + cMatrix[2,2] * X2 * Y2 / N[2])
      dW2 = beta * (cMatrix[2,1] * X2 * Y1 / N[1] + cMatrix[2,2] * X2 * Y2 / N[2]) - sigma * W2
      dY2 = sigma * W2 - gamma * Y2
      dZ2 = gamma * Y2
      list(c(dX1, dW1, dY1, dZ1, dX2, dW2, dY2, dZ2))
      })
  }
  
  # Numerically solve the system of differential equations over time frame tf
  df <- as.data.frame(ode(y = x0, times = seq(0, tf, by = 1), func  = f, parms = parameters))
  
  # Reorganization of output
  df1 <- df %>% select(time, X1, W1, Y1, Z1)
  colnames(df1) <- c("time", "X", "W", "Y", "Z")
  df2 <- df %>% select(time, X2, W2, Y2, Z2)
  colnames(df2) <- c("time", "X", "W", "Y", "Z")
  return(list(df1, df2))
}
```

The following function implements a two-population stochastic/deterministic version of a SEIR metapopulation model over a time frame if `tf` days. The population size, vaccine coverage and initial number of infectives of each population is given by `N` `v`, `Y0` respectively. The transmission rate `beta`, the average latency period `1 / sigma` and the average recovery period `1 / gamma` are the same for all populations. The commuter coefficients among the populations are given by the matrix `fM`.

```{r TwoCityApprox2}
TwoCityApprox2 <- function(n = 2, N = c(1e6, 1e6), v = c(0.95, 0.5), Y0 = c(1, 0),
                          fM = matrix(c(0.98, 0.02, 0.1, 0.9), nrow = 2, ncol = 2, byrow = FALSE), 
                          tf = 365) {
  
 # Probability of epidemic for all populations starting with a single infective
 epi_prob <- predict(y1, x = data.frame(v))$y$v

 # Generate prevalence curves for infected populations
  f1 <- function(x, y) {
    if (x == 0)
      return (data.frame(time = seq(0, tf), X = rep(0, tf+1), W = rep(0, tf+1), 
                         Y = rep(0, tf+1), Z = rep(0, tf+1)))
    else 
      return (dseir(N = N[y], Y0 = Y0[y], v = v[y], tf = tf))
  }
  P <- purrr::map2(Y0, seq(1, n), f1)
  I <- do.call(cbind, purrr::map(P, function(x) x$Y))
  
 # Calculation of coupling coefficients
  q <- N[2]/N[1]
  c11 <- (1 - fM[2,1])^2 / (1 - fM[2,1] + fM[1,2]*q) + 
    fM[2,1]^2 / (fM[2,1] + (1 - fM[1,2])*q)
  c12 <- (1 - fM[2,1])*fM[1,2]*q / (1 - fM[2,1] + fM[1,2]*q) + 
    fM[2,1]*(1 - fM[1,2])*q / (fM[2,1] + (1 - fM[1,2])*q)
  c21 <- (1 - fM[1,2])*fM[2,1] / (fM[2,1] + (1 - fM[1,2])*q) + 
    fM[1,2]*(1 - fM[2,1]) / (1 - fM[2,1] + fM[1,2]*q) 
  c22 <- (1 - fM[1,2])^2 * q / (fM[2,1] + (1 - fM[1,2])*q) + 
    fM[1,2]^2 * q / (1 - fM[2,1] + fM[1,2]*q) 
  cMatrix <- matrix(c(c11, c12, c21, c22), nrow = n, ncol = n, byrow = TRUE)

  # Run the simulation over the specified time frame
  for (t in 1:tf) {
    for (i in which(I[t, ] == 0)) {
      prob <- 1 - (1 - epi_prob[i])^(sum(I[t, ] * cMatrix[i, ])) # probability of epidemic
      if (runif(1, 0, 1) < prob) {
        oldEpis <- which(I[t, ] != 0) # number of existing epidemics
        noEpis <- which(I[t, ] == 0)[which(I[t, ] == 0) != i]  
        
        # modified coupling matrix with only pops. with epidemics
        if (length(which(I[t, ] == 0)) > 1) {
          newC <- cMatrix[-noEpis, ]
          newC <- newC[, -noEpis]
        }
        else newC <- cMatrix
        
        # Organize initial values for the deterministic metapopulation model
        inf <- sum(I[t, ] * cMatrix[i, ]) 
        vac <- round(v[i] * (N[i] - inf))
        oIni <- do.call(rbind, lapply(P, function(p) {
          return(c(p$X[t], p$W[t], p$Y[t], p$Z[t]))})[oldEpis])
        pos <- length(oldEpis[oldEpis < i]) + 1 # position of newly started epi. pop.
        
        # Simulate the deterministic metapopulation model
        Padd <- dseir2(X0 = insert(oIni[, 1], pos, N[i] - inf - vac), 
                       Y0 = insert(oIni[, 3], pos, inf),
                       W0 = insert(oIni[, 2], pos, 0), Z0 = insert(oIni[, 4], pos, vac), 
                       cMatrix = newC, tf = tf - t)

        # Update the dynamics of each population
        newEpis <- insert(oldEpis, pos, i)
        cutP <- purrr::map(newEpis, function(x) P[[x]][ !(P[[x]]$time %in% seq(t, tf+1)), ])
        Padd <- purrr::map(1:length(newEpis), function(x) mutate(Padd[[x]], time = seq(t, tf)))
        P[newEpis] <- purrr::map(1:length(newEpis), function(x) dplyr::bind_rows(cutP[[x]], Padd[[x]]))
        I <- do.call(cbind, purrr::map(P, function(x) x$Y))
      }
    }
  }
  df <- as.data.frame(cbind(I, time = P[[1]]$time))
  varNames <- unlist(purrr::map(seq(1, n), function(x) paste0("Y", x)))
  colnames(df) <- c(varNames, "time")
  return(df %>% dplyr::select(time, dplyr::everything()))
}
```

Let's see how this approximate two-city model compares with the stochastic two-city model. 
```{r}
sim20 <- TwoCityApprox2(n = 2, N = c(1e6, 1e6), v = c(0.5, 0.95), Y0 = c(1, 0), tf = 365, 
                       fM = matrix(c(0.9, 0.1, 0.02, 0.98), nrow = 2, ncol = 2, byrow = FALSE))
```

```{r}
sim20 %>% dplyr::select(time, Y1, Y2) %>%
  gather(key = population, value = number, Y1, Y2) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) +
  geom_line() + labs(x = "Time (days)", y = "Prevalence", title = "Approximate Model #2")
```

```{r}
sim2City <- seirNCity(num = 2, N = c(1e6, 1e6), 
                      p = c(0.5, 0.95), I0 = c(1, 0),
                      fM = matrix(c(0.9, 0.1, 0.02, 0.98),
                                 nrow = 2, ncol = 2, byrow = FALSE), tf = 365)
```

```{r}
sim2City %>% dplyr::select(time, I1, I2) %>%
  gather(key = population, value = number, I1, I2) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) + geom_line() + 
  labs(x = "Time (days)", y = "Prevalence", title = "Exact Model")
```

The approximate deterministic/stochastic model is consistent with the stochastic model. 

Let's calculate the average time until the peak of the epidemic in population 1 and population 2 in both model.
This will also serve as an opportunity to compare the running times of each of the models. 
```{r}
library(timeR)
f1 <- function(n = 2, N = c(1e6, 1e6), v = c(0.5, 0.95), Y0 = c(1,0), tf = 365, 
                        fM = matrix(c(0.9, 0.1, 0.02, 0.98), nrow = 2, ncol = 2, byrow = FALSE)) {
  df <- TwoCityApprox2(n = n, N = N, v = v, Y0 = Y0, tf = tf, fM = fM)
  c(df[which.max(df$Y1), 1], df[which.max(df$Y2), 1])
}

f2 <- function(num = 2, N = c(1e6, 1e6), p = c(0.5, 0.95), I0 = c(1,0), 
               fM = matrix(c(0.9, 0.1, 0.02, 0.098), nrow = 2, ncol = 2, byrow = FALSE), tf = 365) {
  df <- seirNCity(num = num, N = N, p = p, I0 = I0, fM = fM)
  c(df[which.max(df$I1), 1], df[which.max(df$I2), 1])
}

timer <- createTimer(FALSE)
n <- 1000
timer$start("Deterministic Model")
approxModel <- colMeans(do.call(rbind, purrr::rerun(n, f1())))
timer$stop("Deterministic Model")
timer$start("Stochastic Model")
test <- do.call(rbind, purrr::rerun(n, f2()))
exactModel <- colMeans(do.call(rbind, purrr::rerun(n, f2())))
timer$stop("Stochastic Model")
```

```{r}
data.frame("Population 1 Peak" = approxModel[1], "Population 2 Peak" = approxModel[2])
data.frame("Population 1 Peak" = exactModel[1], "Population 2 Peak" = exactModel[2])
timer
```

The times of the epidemic peaks in both models are generally consistent. Furthermore, based on this very preliminary analysis the approximate model is about 5 times faster than the approximate model. 

### N population model 
Computes the epidynamics of `n` populations over `tf` days with a disease parameterised by a `beta` transmission rate per capita, a latency period of `1 / sigma` days and a recovery period of `1 / gamma` days. Furthermore, each population is initialized with  `X0` susceptibles, `W0` infected but not infectious individuals, `Y0` infectives and `Z0` recovered individuals. The populations are coupled according to the `n`-by-`n` matrix `cMatrix`. It returns a list of length `n` with each element a dataframe with columns `time`, `X`, `W`, `Y`, `Z` that describe the dynamics of the epidemic over time. Note that the list is ordered according to the ordering of the populations when inputted as arguments. Note also that the pre-computed coupling matrix must be provided; it will not be computed by the function itself. 

```{r dseirN}
dseirN <- function(n = 3, X0 = c(1e6, 1e6, 1e6), W0 = c(0, 0, 0), Y0 = c(1, 0, 0), Z0 = c(0, 0, 0),
                   beta = 5, sigma = 1/7, gamma = 1/7, cMatrix,
                   tf = 100, ...) {
  # Initialization of variables
  N <- colSums(rbind(X0, W0, Y0, Z0), na.rm=TRUE)
  varNames <- purrr::map(seq(1, n), function(x) c(paste0("X", x),paste0("W", x),paste0("Y", x),paste0("Z", x)))
  x0 <- unlist(purrr::map(seq(1, n), function(x) {
    tmp <- c(X0[x], W0[x], Y0[x], Z0[x]); names(tmp) <- varNames[[x]]; tmp}))
  
  # Parameter vector
  parameters <- c(beta = beta, sigma = sigma, gamma = gamma, N = N, cMatrix = cMatrix)
  
  # Returns the set of differential rate functions
  f <- function(t, state, parameters) {
    with(as.list(c(state, parameters)), {
      cityRates <- function(j) {
        infectionRate <- 
          sum(unlist(purrr::map(seq(1, n), 
                                function(k) cMatrix[j, k] * state[paste0("X", j)] * 
                                  state[paste0("Y", k)] / N[k])))
        c(-beta * infectionRate, beta * infectionRate - sigma * state[paste0("W", j)],
          sigma * state[paste0("W", j)] - gamma * state[paste0("Y", j)], gamma * state[paste0("Y", j)])
    }
    list(unlist(purrr::map(seq(1, n), cityRates)))
    })
  }
  
  # Numerically solves the set of differential equation over time frame tf
  df <- as.data.frame(ode(y = x0, times = seq(0, tf, by = 1), func  = f, parms = parameters))
  
  # Reorganization of output
  return(purrr::map(seq(1, n), function(x) {
    tmp <- df %>% select(time, varNames[[x]]); colnames(tmp) <- c("time", "X", "W", "Y", "Z"); tmp}))
}
```

The following function computes and returns the coupling matrix for `n` populations each with population size `N` and commuter coefficients given by the matrix `fM`.
```{r Rozhnova coupling matrix}
generate_coupling_matrix <- function(n = 3, N = c(1e6, 1e6, 1e6),
                                     fM = matrix(c(0.098, 0.001, 0.001, 0.47, 0.53, 0, 0.01, 0, 0.09), 
                                                 nrow = 3, ncol = 3, byrow = FALSE)) {
  f <- function(j, k) {
    if (j == k) {
      return(fM[j,j]^2 * N[j] / (fM[j,k] * N[j] + sum((t(N * t(fM))[j,])[-j])) +
               sum(unlist(purrr::map(seq(1:n)[-j], 
                                     function(x) (fM[x,j]^2 * N[j] / 
                                                    (fM[x,x] * N[x] + sum(((t(N * t(fM))[x,])[-x]))))))))
      }
    if (j != k) {
      return(fM[j,j] * fM[j,k] * N[k] / (fM[j,j] * N[j] + sum((t(N * t(fM))[j,])[-j])) + 
               fM[k,j] * fM[k,k] * N[k] / (fM[k,k] * N[k] + sum((t(N * t(fM))[k,])[-k])) + 
               sum(unlist(purrr::map(seq(1:n)[-c(j,k)], 
                                     function(x) (fM[x,j] * fM[x,k] * N[k] /
                                                    (fM[x,x] * N[x] + sum((t(N * t(fM))[x,])[-x])))))))
    }
  }
  myIter <- iterpc(n, 2, ordered = TRUE, replace = TRUE)
  coeffs <- unlist(purrr::map2(t(getall(myIter))[1,], t(getall(myIter))[2,], f))
  cMatrix <- matrix(coeffs, nrow = n, ncol = n, byrow = TRUE)
  return(cMatrix)
}
```

Let's try the function `deirN()` with the default parameters. Note that a precomputed coupling matrix must be provided to the function. 
```{r}
# Compute the coupling matrix
N <- c(1e6+1, 1e6, 1e6)
fM <- matrix(c(0.098, 0.001, 0.001, 0.47, 0.53, 0, 0.01, 0, 0.09), nrow = 3, ncol = 3, byrow = FALSE)
cMatrix <- generate_coupling_matrix(n = 3, N  = N, fM = fM)

# Solve the deterministic metapopulation model
sim21 <- dseirN(cMatrix = cMatrix)
df <- as.data.frame(do.call(cbind, purrr::map(sim21, function(x) x$Y)))
colnames(df) <- c("Y1", "Y2", "Y3")
df <- df %>% dplyr::mutate("time" = sim21[[1]]$time) %>% select(time, dplyr::everything())

# Plot the results
df %>% gather(key = population, value = number, Y1, Y2, Y3) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) + geom_line() + 
  labs(x = "Time (days)", y = "Prevalence", title = "Deterministic SEIR Metapopulation")
```

The following function implements a `n`-population stochastic/deterministic version of a SEIR metapopulation model over a time frame if `tf` days. The population size, vaccine coverage and initial number of infectives of each population is given by `N` `v`, `Y0` respectively. The transmission rate `beta`, the average latency period `1 / sigma` and the average recovery period `1 / gamma` are the same for all populations. The commuter coefficients among the populations are given by the matrix `fM`.

```{r nCityApprox2}
nCityApprox2 <- function(n = 2, N = c(1e6, 1e6), v = c(0.95, 0.5), Y0 = c(1, 0),
                         beta = 5, sigma = 1/7, gamma = 1/7,
                         fM = matrix(c(0.98, 0.02, 0.1, 0.9), nrow = 2, ncol = 2, byrow = FALSE), 
                         tf = 365) {
  
 # Probability of epidemic for all populations starting with a single infective
 epi_prob <- predict(y1, x = data.frame(v))$y$v
 
 # Calculation of coupling coefficients
 cMatrix <- generate_coupling_matrix(n = n, N = N, fM = fM)

 # Generate prevalence curves for initial infected populations
 P <- purrr::map(seq(1, n), function(x) 
    return(data.frame(time = seq(0, tf), X = rep(0, tf+1), W = rep(0, tf+1), 
                      Y = rep(0, tf+1), Z = rep(0, tf+1))))
 currentEpis <- which(Y0 > 0)
 if (length(currentEpis) > 1) {
   z <- round(v[currentEpis] * (N[currentEpis] - Y0[currentEpis]))
   y <- Y0[currentEpis]
   x <- N[currentEpis] - Y0[currentEpis] - z[currentEpis]
   w <- rep(0, length(currentEpis))
   newC <- cMatrix[currentEpis, ]
   newC <- newC[, currentEpis]
   epiP <- dseirN(n = length(currentEpis), X0 = x, Y0 = y, W0 = w, Z0 = z, tf = tf, 
                  cMatrix = newC)
 }
 else
   epiP <- list(dseir(N = N[currentEpis], Y0 = Y0[currentEpis], v = v[currentEpis], tf = tf))
 P[currentEpis] <- epiP
 I <- do.call(cbind, purrr::map(P, function(x) x$Y))
 
 # Run the simulation over the specified time frame
 for (t in 1:tf) {
   for (i in which(I[t, ] == 0)) {
     prob <- 1 - (1 - epi_prob[i])^(sum(I[t, ] * cMatrix[i, ])) # probability of epidemic
     if (runif(1, 0, 1) < prob) {
       oldEpis <- which(I[t, ] != 0) # number of existing epidemics
       noEpis <- which(I[t, ] == 0)[which(I[t, ] == 0) != i]
       
       # modified coupling matrix with only pops. with epidemics
       if (length(which(I[t, ] == 0)) > 1) {newC <- cMatrix[-noEpis, ]; newC <- newC[, -noEpis]}
       else newC <- cMatrix
       
       # Organize initial values for the deterministic metapopulation model
       inf <- sum(I[t, ] * cMatrix[i, ]) 
       vac <- round(v[i] * (N[i] - inf))
       oIni <- do.call(rbind, lapply(P, function(p) {
          return(c(p$X[t], p$W[t], p$Y[t], p$Z[t]))})[oldEpis])
       pos <- length(oldEpis[oldEpis < i]) + 1
       
       # Simulate the deterministic metapopulation model
       Padd <- dseirN(n = length(oldEpis) + 1, 
                      X0 = insert(oIni[, 1], pos, N[i] - inf - vac), 
                      Y0 = insert(oIni[, 3], pos, inf),
                      W0 = insert(oIni[, 2], pos, 0), Z0 = insert(oIni[, 4], pos, vac), 
                      cMatrix = newC, tf = tf - t)
       
       # Update the dynamics of each population
       newEpis <- insert(oldEpis, pos, i) 
       cutP <- purrr::map(newEpis, function(x) P[[x]][ !(P[[x]]$time %in% seq(t, tf+1)), ])
       Padd <- lapply(Padd, function(x) mutate(x, time = seq(t, tf)))
       P[newEpis] <- purrr::map2(cutP, Padd, function(x, y) dplyr::bind_rows(x, y))
       I <- do.call(cbind, purrr::map(P, function(x) x$Y))
      }
    }
 }
 
 df <- as.data.frame(cbind(I, time = P[[1]]$time))
 varNames <- unlist(purrr::map(seq(1, n), function(x) paste0("Y", x)))
 colnames(df) <- c(varNames, "time") 
 return(df %>% dplyr::select(time, dplyr::everything()))
}
```

Lets see how this approximate n-city model compares with the stochastic two-city model.
```{r}
sim20 <- nCityApprox2(n = 2, N = c(1e6, 1e6), v = c(0.5, 0.95), Y0 = c(1, 0), tf = 100, 
                       fM = matrix(c(0.9, 0.1, 0.02, 0.98), nrow = 2, ncol = 2, byrow = FALSE))
```

```{r}
sim20 %>% dplyr::select(time, Y1, Y2) %>%
  gather(key = population, value = number, Y1, Y2) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) +
  geom_line() + labs(x = "Time (days)", y = "Prevalence", title = "Approximate Model #2")
```

```{r}
sim2City <- seirNCity(num = 2, N = c(1e6, 1e6), 
                      p = c(0.5, 0.95), I0 = c(1, 0),
                      fM = matrix(c(0.9, 0.1, 0.02, 0.98),
                                 nrow = 2, ncol = 2, byrow = FALSE), tf = 100)
```

```{r}
sim2City %>% dplyr::select(time, I1, I2) %>%
  gather(key = population, value = number, I1, I2) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) + geom_line() + 
  labs(x = "Time (days)", y = "Prevalence", title = "Exact Model")
```

Lets see how this approximate n-city model compares with the stochastic three-city model.
```{r}
sim21 <- nCityApprox2(n = 3, N = c(1e6, 1e6, 1e6), v = c(0.95, 0.5, 0.95), Y0 = c(1, 0, 0),
         fM = matrix(c(0.998, 0.001, 0.001, 0.1, 0.9, 0, 0.1, 0, 0.9), 
                     nrow = 3, ncol = 3, byrow = FALSE), tf = 150)
```

```{r}
sim21 %>% dplyr::select(time, Y1, Y2, Y3) %>%
  gather(key = population, value = number, Y1, Y2, Y3) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) +
  geom_line() + labs(x = "Time (days)", y = "Prevalence", title = "Approximate Model #2")
```

```{r}
sim3City <- seirNCity(num = 3, N = c(1e6, 1e6, 1e6), 
                      p = c(0.95, 0.5, 0.95), I0 = c(0, 1, 0),
                      fM = matrix(c(0.998, 0.001, 0.001, 0.1, 0.9, 0, 0.1, 0, 0.9), 
                                 nrow = 3, ncol = 3, byrow = FALSE), tf = 150)
```

```{r}
sim3City %>% dplyr::select(time, I1, I2, I3) %>%
  gather(key = population, value = number, I1, I2, I3) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) +
  geom_line() + labs(x = "Time (days)", y = "Prevalence", title = "Exact Model")
```

Lets see how this approximate n-city model compares with the stochastic four-city model.
```{r}
sim22 <- nCityApprox2(n = 4, N = c(1e6, 1e6, 1e6, 1e6), v = c(0.95, 0.5, 0.95, 0.95), Y0 = c(1, 1, 0, 0),
         fM = matrix(c(0.998, 0.001, 0.001, 0.001, 0.025, 0.9, 0.025, 0.05, 
                       0.025, 0.025, 0.9, 0.05, 0.1, 0, 0, 0.9), 
                     nrow = 4, ncol = 4, byrow = FALSE), tf = 200)
```

```{r}
sim22 %>% dplyr::select(time, Y1, Y2, Y3, Y4) %>%
  gather(key = population, value = number, Y1, Y2, Y3, Y4) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) +
  geom_line() + labs(x = "Time (days)", y = "Prevalence", title = "Approximate Model #2")
```

```{r}
sim4City <- seirNCity(n = 4, N = c(1e6, 1e6, 1e6, 1e6), p = c(0.95, 0.5, 0.95, 0.95), I0 = c(1, 1, 0, 0),
                      fM = matrix(c(0.998, 0.001, 0.001, 0.001, 0.025, 0.9, 0.025, 0.05, 
                                    0.025, 0.025, 0.9, 0.05, 0.1, 0, 0, 0.9), 
                                  nrow = 4, ncol = 4, byrow = FALSE), tf = 200)
```

```{r}
sim4City %>% dplyr::select(time, I1, I2, I3, I4) %>%
  gather(key = population, value = number, I1, I2, I3, I4) %>%
  ggplot(aes(x = time, y = number, color = population, group = population)) +
  geom_line() + labs(x = "Time (days)", y = "Prevalence", title = "Exact Model")
```

Let's calculate the average time until the peak of the epidemic in all populations in both model.
This will also serve as an opportunity to compare the running times of each of the models. 
```{r}
library(timeR)
f1 <- function(n = 4, N = c(1e6, 1e6, 1e6, 1e6), v = c(0.95, 0.5, 0.95, 0.95), Y0 = c(1, 1, 0, 0),
               fM = matrix(c(0.998, 0.001, 0.001, 0.001, 0.025, 0.9, 0.025, 0.05, 
                             0.025, 0.025, 0.9, 0.05, 0.1, 0, 0, 0.9), 
                           nrow = 4, ncol = 4, byrow = FALSE), tf = 200) {
  df <- nCityApprox2(n = n, N = N, v = v, Y0 = Y0, tf = tf, fM = fM)
  c(df[which.max(df$Y1), 1], df[which.max(df$Y2), 1], df[which.max(df$Y3), 1], df[which.max(df$Y4), 1])
}

f2 <- function(num = 4, N = c(1e6, 1e6, 1e6, 1e6), p = c(0.95, 0.5, 0.95, 0.95), I0 = c(1, 1, 0, 0),
               fM = matrix(c(0.998, 0.001, 0.001, 0.001, 0.025, 0.9, 0.025, 0.05, 
                             0.025, 0.025, 0.9, 0.05, 0.1, 0, 0, 0.9), 
                           nrow = 4, ncol = 4, byrow = FALSE), tf = 200) {
  df <- seirNCity(num = num, N = N, p = p, I0 = I0, fM = fM, tf = 200)
  c(df[which.max(df$I1), 1], df[which.max(df$I2), 1], df[which.max(df$I3), 1], df[which.max(df$I4), 1])
}

timer <- createTimer(FALSE)
n <- 1000
timer$start("Deterministic Model")
approxModel <- colMeans(do.call(rbind, purrr::rerun(n, f1())))
timer$stop("Deterministic Model")
timer$start("Stochastic Model")
test <- do.call(rbind, purrr::rerun(n, f2()))
exactModel <- colMeans(do.call(rbind, purrr::rerun(n, f2())))
timer$stop("Stochastic Model")
```

```{r}
data.frame("Population 1 Peak" = approxModel[1], "Population 2 Peak" = approxModel[2],
           "Population 3 Peak" = approxModel[3], "Population 4 Peak" = approxModel[4])
data.frame("Population 1 Peak" = exactModel[1], "Population 2 Peak" = exactModel[2], 
           "Population 3 Peak" = exactModel[3], "Population 4 Peak" = exactModel[4])
timer
```